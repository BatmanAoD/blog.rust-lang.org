<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-12-03T14:16:57Z</updated>

    
    <entry>
        <title>Constant propagation is now on by default in nightly</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html" type="text/html" title="Constant propagation is now on by default in nightly" />
        <published>2019-12-02T00:00:00Z</published>
        <updated>2019-12-02T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html">&lt;p&gt;I'm pleased to announce that the &lt;a href=&quot;https://blog.rust-lang.org/2016/04/19/MIR.html&quot;&gt;Mid-level IR&lt;/a&gt; (MIR) constant propagation pass has been &lt;a href=&quot;https://github.com/rust-lang/rust/pull/66074&quot;&gt;switched on&lt;/a&gt; by default on Rust nightly which will eventually become Rust 1.41!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#what-is-constant-propagation&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-is-constant-propagation&quot;&gt;&lt;/a&gt;What is constant propagation?&lt;/h2&gt;
&lt;p&gt;Constant propagation is an optimization where the compiler recognizes code that can be run at compile time, evaluates it, and replaces the original code with the result.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const X: u32 = 2;

let y = X + X;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rather than evaluating &lt;code&gt;X + X&lt;/code&gt; at runtime, the compiler can recognize that the value of &lt;code&gt;X&lt;/code&gt; is known at compile time and replace it with the correct value resulting in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const X: u32 = 2;

let y = 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This optimization is opportunistic and automatically recognizes constants even when they are not declared as such:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;struct Point {
  x: u32,
  y: u32,
}

let a = 2 + 2; // optimizes to 4
let b = [0, 1, 2, 3, 4, 5][3]; // optimizes to 3
let c = (Point { x: 21, y: 42 }).y; // optimizes to 42
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#propagation-into-control-flow&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;propagation-into-control-flow&quot;&gt;&lt;/a&gt;Propagation into control flow&lt;/h2&gt;
&lt;p&gt;The constant propagation pass also handles propagating into control flow.
For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const Foo: Option&amp;lt;u8&amp;gt; = Some(12);

let x = match Foo {
   None =&amp;gt; panic!(&amp;quot;no value&amp;quot;),
   Some(v) =&amp;gt; v,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const Foo: Option&amp;lt;u8&amp;gt; = Some(12);

let x = 12;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is very helpful for checked math, the default in &lt;code&gt;debug&lt;/code&gt; mode, which introduces additional control flow after every operation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let x = 2 + 4 * 6;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;actually operates like this with overflow checking enabled:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let (_tmp0, overflowed) = CheckedMultiply(4, 6);
assert!(!overflowed, &amp;quot;attempt to multiply with overflow&amp;quot;);

let (_tmp1, overflowed) = CheckedAdd(_tmp0, 2);
assert!(!overflowed, &amp;quot;attempt to add with overflow&amp;quot;);

let x = _temp1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which adds quite a bit of control flow!
Constant propagation evaluates the math at compile time and reduces this to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let _tmp0 = 24;
assert!(!false, &amp;quot;attempt to multiply with overflow&amp;quot;);

let _tmp1 = 26;
assert!(!false, &amp;quot;attempt to add with overflow&amp;quot;);

let x = 26;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which is further reduced to just:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let x = 26;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#compiler-performance&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;compiler-performance&quot;&gt;&lt;/a&gt;Compiler performance&lt;/h2&gt;
&lt;p&gt;As you might have guessed, reducing the amount of control flow processed by the Rust compiler has a positive effect on compile times.
We're seeing 2-10% improvement on a variety of test cases in both debug and release mode.
Even though LLVM has its own constant propagation pass, we see improvements because our pass operates on MIR while it is still generic.
The more concrete instances of a generic function that are instantiated, the larger the payoff from this optimization.&lt;/p&gt;
&lt;p&gt;We've suspected for a while that the verbose LLVM IR the Rust compiler generates contributes considerably to long compilation times.
By implementing optimizations like this, we believe there is significant potential to lower compile times by generating better LLVM IR.
If you'd like to get involved with the MIR Optimizations working group, stop by our &lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/189540-t-compiler.2Fwg-mir-opt&quot;&gt;Zulip channel&lt;/a&gt; and say hello!&lt;/p&gt;
</content>

        <author>
            <name>Wesley Wiser</name>
        </author>
    </entry>
    
    <entry>
        <title>`if` and `match` in constants on nightly rust</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/25/const-if-match.html" type="text/html" title="`if` and `match` in constants on nightly rust" />
        <published>2019-11-25T00:00:00Z</published>
        <updated>2019-11-25T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/25/const-if-match.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/25/const-if-match.html">&lt;p&gt;&lt;strong&gt;TLDR; &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt; are now usable in constants on the latest nightly.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As a result, you can now write code like the following and have it execute at
compile-time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;static PLATFORM: &amp;amp;str = if cfg!(unix) {
    &amp;quot;unix&amp;quot;
} else if cfg!(windows) {
    &amp;quot;windows&amp;quot;
} else {
    &amp;quot;other&amp;quot;
};

const _: () = assert!(std::mem::size_of::&amp;lt;usize&amp;gt;() == 8, &amp;quot;Only 64-bit platforms are supported&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt; can also be used in the body of a &lt;code&gt;const fn&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const fn gcd(a: u32, b: u32) -&amp;gt; u32 {
    match (a, b) {
        (x, 0) | (0, x) =&amp;gt; x,

        (x, y) if x % 2 == 0 &amp;amp;&amp;amp; y % 2 == 0 =&amp;gt; 2*gcd(x/2, y/2),
        (x, y) | (y, x) if x % 2 == 0 =&amp;gt; gcd(x/2, y),

        (x, y) if x &amp;lt; y =&amp;gt; gcd((y-x)/2, x),
        (x, y) =&amp;gt; gcd((x-y)/2, y),
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#what-exactly-is-going-on-here&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-exactly-is-going-on-here&quot;&gt;&lt;/a&gt;What exactly is going on here?&lt;/h2&gt;
&lt;p&gt;The following expressions,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;if let&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;can now appear in any of the following contexts,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const fn&lt;/code&gt; bodies&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt; and associated &lt;code&gt;const&lt;/code&gt; initializers&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; and &lt;code&gt;static mut&lt;/code&gt; initializers&lt;/li&gt;
&lt;li&gt;array initializers&lt;/li&gt;
&lt;li&gt;const generics (EXPERIMENTAL)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if &lt;code&gt;#![feature(const_if_match)]&lt;/code&gt; is enabled for your crate.&lt;/p&gt;
&lt;p&gt;You may have noticed that the short-circuiting logic operators, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and
&lt;code&gt;||&lt;/code&gt;, were already legal in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;. This was accomplished by
translating them to their non-short-circuiting equivalents, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;
respectively. Enabling the feature gate will turn off this hack and make &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;
and &lt;code&gt;||&lt;/code&gt; behave as you would expect.&lt;/p&gt;
&lt;p&gt;As a side-effect of these changes, the &lt;code&gt;assert&lt;/code&gt; and &lt;code&gt;debug_assert&lt;/code&gt; macros
become usable in a const context if &lt;code&gt;#![feature(const_panic)]&lt;/code&gt; is also
enabled. However, the other assert macros (e.g., &lt;code&gt;assert_eq&lt;/code&gt;,
&lt;code&gt;debug_assert_ne&lt;/code&gt;) remain forbidden, since they need to call &lt;code&gt;Debug::fmt&lt;/code&gt; on
their arguments.&lt;/p&gt;
&lt;p&gt;The looping constructs, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and &lt;code&gt;loop&lt;/code&gt; are also forbidden and will
be &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;feature-gated separately&lt;/a&gt;. As you have seen above, loops can be
emulated with recursion as a temporary measure. However, the non-recursive
version will usually be more efficient since rust does not (to my knowledge)
do tail call optimization.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;code&gt;?&lt;/code&gt; operator remains forbidden in a const context, since its
desugaring contains a call to &lt;code&gt;From::from&lt;/code&gt;. The design for &lt;code&gt;const&lt;/code&gt; trait
methods is still being discussed, and both &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;, which desugars to a
call to &lt;code&gt;IntoIterator::into_iter&lt;/code&gt;, will not be usable until a final decision is
reached.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-next?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-next?&quot;&gt;&lt;/a&gt;What's next?&lt;/h2&gt;
&lt;p&gt;This change will allow a great number of standard library functions to be made
&lt;code&gt;const&lt;/code&gt;. You can help with this process! To get started, here's a &lt;a href=&quot;https://github.com/rust-lang/rust/issues/53718&quot;&gt;list of
numeric functions&lt;/a&gt; that can be constified with little effort.
Conversion to a &lt;code&gt;const fn&lt;/code&gt; requires two steps. First, &lt;code&gt;const&lt;/code&gt; is added to a
function definition along with a &lt;code&gt;#[rustc_const_unstable]&lt;/code&gt; attribute. This
allows nightly users to call it in a const context. Then, after a period of
experimentation, the attribute is removed and the constness of that function is
stabilized. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61635&quot;&gt;#61635&lt;/a&gt; for an example of the first step and &lt;a href=&quot;https://github.com/rust-lang/rust/pull/64028&quot;&gt;#64028&lt;/a&gt; for an
example of the second.&lt;/p&gt;
&lt;p&gt;Personally, I've looked forward to this feature for a long time, and I can't
wait to start playing with it. If you feel the same, I would greatly
appreciate if you tested the limits of this feature! Try to sneak &lt;code&gt;Cell&lt;/code&gt;s and
types with &lt;code&gt;Drop&lt;/code&gt; impls into places they shouldn't be allowed, blow up the
stack with poorly implemented recursive functions (see &lt;code&gt;gcd&lt;/code&gt; above), and let
us know if something goes horribly wrong.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#what-took-you-so-long&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-took-you-so-long&quot;&gt;&lt;/a&gt;What took you so long?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.github.io/rustc-guide/miri.html&quot;&gt;The Miri engine&lt;/a&gt;, which rust uses under the hood for compile-time
function evaluation, has been capable of this for a while now. However, rust
needs to statically guarantee certain properties about variables in a &lt;code&gt;const&lt;/code&gt;,
such as whether they allow for interior mutability or whether they have a
&lt;code&gt;Drop&lt;/code&gt; implementation that needs to be called. For example, we must reject the
following code since it would result in a &lt;code&gt;const&lt;/code&gt; being mutable at runtime!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const CELL: &amp;amp;std::cell::Cell&amp;lt;i32&amp;gt; = &amp;amp;std::cell::Cell::new(42); // Not allowed...

fn main() {
    CELL.set(0);
    println!(&amp;quot;{}&amp;quot;, CELL.get()); // otherwise this could print `0`!!!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, it is sometimes okay for a &lt;code&gt;const&lt;/code&gt; to contain a reference to a &lt;em&gt;type&lt;/em&gt;
that may have interior mutability, as long as we can prove that the actual
&lt;em&gt;value&lt;/em&gt; of that type does not. This is particularly useful for &lt;code&gt;enum&lt;/code&gt;s with a
&amp;quot;unit variant&amp;quot; (e.g., &lt;code&gt;Option::None&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const NO_CELL: Option&amp;lt;&amp;amp;std::cell::Cell&amp;lt;i32&amp;gt;&amp;gt; = None; // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A more detailed (but non-normative) treatment of the rules &lt;a href=&quot;https://github.com/rust-lang/const-eval/blob/master/static.md#drop&quot;&gt;for &lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;
and &lt;a href=&quot;https://github.com/rust-lang/const-eval/blob/master/const.md#2-interior-mutability&quot;&gt;for interior mutability&lt;/a&gt; in a const context can be found
on the &lt;a href=&quot;https://github.com/rust-lang/const-eval&quot;&gt;&lt;code&gt;const-eval&lt;/code&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;p&gt;It is not trivial to guarantee properties about the value of a variable when
complex control flow such as loops and conditionals is involved. Implementing
this feature required extending the existing dataflow framework in rust so
that we could properly track the value of each local across the control-flow
graph. At the moment, the analysis is very conservative, especially when values are
moved in and out of compound data types. For example, the following will not
compile, even when the feature gate is enabled.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const fn imprecise() -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let tuple: (Vec&amp;lt;i32&amp;gt;,) = (Vec::new(),);
    tuple.0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the &lt;code&gt;Vec&lt;/code&gt; created by &lt;code&gt;Vec::new&lt;/code&gt; will never actually be dropped
inside the &lt;code&gt;const fn&lt;/code&gt;, we don't detect that all fields of &lt;code&gt;tuple&lt;/code&gt; have been moved
out of, and thus conservatively assume that the drop impl for &lt;code&gt;tuple&lt;/code&gt; will run.
While this particular case is trivial, there are other, more complex ones that
would require a more comprehensive solution. It is an open question how precise
we want to be here, since more precision means longer compile times, even for
users that have no need for more expressiveness.&lt;/p&gt;
</content>

        <author>
            <name>Dylan MacKenzie</name>
        </author>
    </entry>
    
    <entry>
        <title>Upcoming compiler-team design meetings</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/22/upcoming-compiler-team-design-meetings.html" type="text/html" title="Upcoming compiler-team design meetings" />
        <published>2019-11-22T00:00:00Z</published>
        <updated>2019-11-22T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/22/upcoming-compiler-team-design-meetings.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/22/upcoming-compiler-team-design-meetings.html">&lt;p&gt;In our &lt;a href=&quot;https://zulip-archive.rust-lang.org/131828tcompiler/03407planningmeeting20191122.html&quot;&gt;planning meeting today&lt;/a&gt;, the &lt;a href=&quot;https://www.rust-lang.org/governance/teams/compiler&quot;&gt;compiler team&lt;/a&gt; has scheduled our
next batch of upcoming design meetings. You can find the exact times
on the compiler team's &lt;a href=&quot;https://rust-lang.github.io/compiler-team/#meeting-calendar&quot;&gt;meeting calendar&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On Nov 29 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MjM3aGsxdXY0dHBybXBxZ3ZxOGp1ZjdicjEgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
&lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/213&quot;&gt;rust-lang/compiler-team#213&lt;/a&gt;, a proposal to extend rustc's data
structures to enable outside crates to experiment with building a
Rust REPL.&lt;/li&gt;
&lt;li&gt;On Dec 6 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MTByaTZsZG1pZGI1Y2RqdGZ1cHV2djNncTEgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
&lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/175&quot;&gt;rust-lang/compiler-team#175&lt;/a&gt;, which is a plan to modify the
&lt;code&gt;rustc_interface&lt;/code&gt; trait to enable end-to-end query support in the
compiler.&lt;/li&gt;
&lt;li&gt;On Dec 13 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MGxrb2p2cG9lNGFnYTIybWVtcGRoZzdjdmogNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
&lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/222&quot;&gt;rust-lang/compiler-team#222&lt;/a&gt;, which is a roadmap and strategy for
eventually merging rustc, &lt;a href=&quot;https://github.com/rust-analyzer/rust-analyzer/&quot;&gt;rust-analyzer&lt;/a&gt;, and the RLS into one
coherent set of projects.&lt;/li&gt;
&lt;li&gt;On Dec 20 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MW12ZWI4NW9zZ2s2dHRkbW5wbjdjMG43Zm8gNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
&lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/209&quot;&gt;rust-lang/compiler-team#209&lt;/a&gt;, which is a proposal to create a
&amp;quot;major changes process&amp;quot; for the compiler, to augment these design
meetings.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#did-you-know&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;did-you-know&quot;&gt;&lt;/a&gt;Did you know?&lt;/h3&gt;
&lt;p&gt;Most weeks, the compiler team has some sort of design meeting. These
meetings take place on Zulip and are open to all. Every 4 weeks, we do
a planning meeting to pick the next few meetings from the list of open
proposals. You can find &lt;a href=&quot;https://rust-lang.github.io/compiler-team/about/steering-meeting/&quot;&gt;more details about how the compiler-team
steering meeting process here&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-11-14 and 2019-11-21 Lang Team Triage Meetings</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/22/Lang-team-meeting.html" type="text/html" title="2019-11-14 and 2019-11-21 Lang Team Triage Meetings" />
        <published>2019-11-22T00:00:00Z</published>
        <updated>2019-11-22T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/22/Lang-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/22/Lang-team-meeting.html">&lt;p&gt;Since I apparently forgot to post a blog post last week, this blog
post covers two lang-team triage meetings: [2019-11-14] and
[2019-11-21]. Recordings from &lt;a href=&quot;https://youtu.be/0exyVhBmDW0&quot;&gt;both&lt;/a&gt; &lt;a href=&quot;https://youtu.be/X2z3CoV0OUM&quot;&gt;meetings&lt;/a&gt; are also available.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#updates-on-shepherded-items&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;updates-on-shepherded-items&quot;&gt;&lt;/a&gt;Updates on shepherded items&lt;/h2&gt;
&lt;p&gt;Here is a list of the &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/09/11/aic-shepherds-3-0/&quot;&gt;&amp;quot;shepherded items&amp;quot;&lt;/a&gt; that the lang team is
tracking, along with weekly updates on the latest developments.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/const-eval&quot;&gt;const-eval&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;there is progress towards extending the set of expressions
permitted in constants to include &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrows, if/match, and
loops.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/project-ffi-unwind&quot;&gt;project-ffi-unwind&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;current status: currently evaluating whether &amp;quot;C&amp;quot; functions should
permit unwinding by default&lt;/li&gt;
&lt;li&gt;trying to get measurements of the impact on code size&lt;/li&gt;
&lt;li&gt;prototyped the plan in a rustc branch, but needs a few updates and to be executed
on a representative code base (likely Fuschia)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/57893&quot;&gt;Coherence can be bypassed by an indirect impl for a trait object&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;did a &lt;a href=&quot;https://github.com/rust-lang/rust/pull/66037#issuecomment-549575983&quot;&gt;crater run of the proposal&lt;/a&gt; but have only partially analyzed the impact&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;grammar working group — qmx
&lt;ul&gt;
&lt;li&gt;no updates this week&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt; type and fallback — centril
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=a16420f41bbd2496ed07c75cf048189e&quot;&gt;&lt;code&gt;!&lt;/code&gt; is stable on nightly!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#about-the-lang-team-meetings&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;about-the-lang-team-meetings&quot;&gt;&lt;/a&gt;About the lang-team meetings&lt;/h2&gt;
&lt;p&gt;The lang-team triage meetings are held weekly on Zoom (see our
&lt;a href=&quot;https://github.com/rust-lang/lang-team/#meeting-calendar&quot;&gt;meeting calendar&lt;/a&gt;). Anyone is welcome to come and observe. We make a
&amp;quot;best effort&amp;quot; to record the meetings though technical issues sometimes
intervene.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-11-19 Infrastructure Team Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/19/infra-team-meeting.html" type="text/html" title="2019-11-19 Infrastructure Team Meeting" />
        <published>2019-11-19T00:00:00Z</published>
        <updated>2019-11-19T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/19/infra-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/19/infra-team-meeting.html">&lt;p&gt;Meeting run by pietroalbini. Minutes written by pietroalbini.&lt;br /&gt;
Attending: alexcrichton, kennytm, Mark-Simulacrum, pietroalbini, shepmaster&lt;br /&gt;
&lt;a href=&quot;https://discordapp.com/channels/442252698964721669/443148319431065610/646409370095190016&quot;&gt;Start of the conversation&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#migrating-cratesio-behind-cloudfront&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;migrating-cratesio-behind-cloudfront&quot;&gt;&lt;/a&gt;Migrating crates.io behind CloudFront&lt;/h2&gt;
&lt;p&gt;While static.crates.io (hosting the source code of all the published crates) is
behind CloudFront, that’s not true today for the crates.io web application.
This causes problems because crates.io is hosted on Heroku, which requires
pointing a CNAME to Heroku’s DNS. Unfortunately crates.io doesn’t use a
subdomain, which prevents us from using CNAMEs. All our DNS zones are on AWS
Route53, but AWS only supports CNAMEs on the apex pointing to other AWS
resources. Because of that, the crates.io DNS was managed on a different
service until today, causing maintenance issues on our end.&lt;/p&gt;
&lt;p&gt;The solution we’re working torwards is to put CloudFront in front of crates.io,
and that will finally allow us to migrate the crates.io domain to AWS.
pietroalbini is finishing the last infra touches, and we expect to deploy the
changes in the coming days.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#dns-management-with-terraform&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;dns-management-with-terraform&quot;&gt;&lt;/a&gt;DNS management with Terraform&lt;/h2&gt;
&lt;p&gt;pietroalbini announced to the rest of the team that he started working on
migrating the DNS records of our domains to Terraform. He already migrated the
zones of &lt;a href=&quot;https://github.com/rust-lang/simpleinfra/blob/master/terraform/services/dns/cratesio.com.tf&quot;&gt;cratesio.com&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-lang/simpleinfra/blob/master/terraform/services/dns/crates.io.tf&quot;&gt;crates.io&lt;/a&gt;, and he plans to migrate the other ones
over the coming weeks. pietroalbini also wrote &lt;a href=&quot;https://forge.rust-lang.org/infra/docs/dns.html&quot;&gt;documentation&lt;/a&gt; on this setup.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#another-github-actions-ci-configuration-prototype&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;another-github-actions-ci-configuration-prototype&quot;&gt;&lt;/a&gt;Another GitHub Actions CI configuration prototype&lt;/h2&gt;
&lt;p&gt;pietroalbini continued his investigation into another prototype for our new
GitHub Actions configuration. To reiterate, GitHub Actions doesn’t support
templates or includes, so the infrastructure team is looking into a way to
reduce duplication between our pipelines.&lt;/p&gt;
&lt;p&gt;Since the two prototypes presented at last week’s meeting weren’t liked by all
the team, pietroalbini continued experimenting, and the prototype presented
this week was based around YAML anchors, a standard YAML feature to reuse parts
of data inside a single file. Unfortunately GitHub Actions explicitly disables
YAML anchors, so pietroalbini wrote a small tool that pre-generates the
expanded configuration file and commits it into the repo.&lt;/p&gt;
&lt;p&gt;The team liked this approach much more, as it doesn’t introduce any new
configuration syntax while keeping the configuration files in a manageable
state. pietroalbini is going to polish the prototype and open a PR for it in
the coming days.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-11-14 Compiler Team Triage Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/19/compiler-team-meeting.html" type="text/html" title="2019-11-14 Compiler Team Triage Meeting" />
        <published>2019-11-19T00:00:00Z</published>
        <updated>2019-11-19T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/19/compiler-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/19/compiler-team-meeting.html">&lt;p&gt;The compiler team had our weekly triage meeting on 2019-11-14.
You can find the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/minutes/triage-meeting/2019-11-14/&quot;&gt;minutes&lt;/a&gt; on the &lt;a href=&quot;https://github.com/rust-lang/compiler-team&quot;&gt;compiler-team&lt;/a&gt; repository.
Each week, we have general announcements from the team followed by check-ins from two of the compiler team working groups.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#announcements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;announcements&quot;&gt;&lt;/a&gt;Announcements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Request for assistance: &amp;quot;Rustc panics (NoSolution): could not prove Binder(projection soup)&amp;quot; &lt;a href=&quot;https://github.com/rust-lang/rust/issues/65581&quot;&gt;#65581&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Request for assistance: &amp;quot;Rust 1.38 regressions weren't fully triaged&amp;quot; &lt;a href=&quot;https://github.com/rust-lang/rust/issues/65577&quot;&gt;#65577&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Request for assistance: &amp;quot;Miscompilation with target-cpu=znver1 (AMD Ryzen 1000/2000 series) on Windows + LLVM 9.&amp;quot; &lt;a href=&quot;https://github.com/rust-lang/rust/issues/63959&quot;&gt;#63959&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cjgillot&quot;&gt;@cjgillot&lt;/a&gt; replaced a lot of TypeFoldable impls with a derive &lt;a href=&quot;https://github.com/rust-lang/rust/pull/66384&quot;&gt;#66384&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Infra team has finished evaluating GitHub Actions and we're switching!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This will have a signficant, positive impact on CI build time.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/centril&quot;&gt;@centril&lt;/a&gt; is fixing useless &lt;code&gt;&amp;lt;std macros&amp;gt;&lt;/code&gt; spans &lt;a href=&quot;https://github.com/rust-lang/rust/pull/66364&quot;&gt;#66364&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#working-group-sync&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;working-group-sync&quot;&gt;&lt;/a&gt;Working group sync&lt;/h2&gt;
&lt;p&gt;This week we heard from three working groups because we ran out of time in the previous meeting.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-polonius&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-polonius&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/polonius/&quot;&gt;wg-polonius&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Made a lot of progress on the completeness goals with move/initialization errors and subset errors both getting close to completion.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fixed the last failure in the rustc test suite.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There are still the same 2 OOMs as last time, we haven't had much time to look at those yet.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Made diagnostics output match NLL in a lot more cases.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Did some cleanup in our terminology by picking better names for our atoms hopefully making it clearer in the process, and more work is planned here.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;origin&amp;quot; instead of &amp;quot;region&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;path&amp;quot; instead of &amp;quot;MovePath&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is a &lt;a href=&quot;https://rust-lang.github.io/polonius/&quot;&gt;polonius book&lt;/a&gt; now! It's sparse at the moment but more documentation work is in-flight and planned.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The exploration and prototype on the rules offering more flow-sensitive precision for the analysis has also progressed a lot.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There's also been some refactoring, and quite a bit of work on performance. Since the latter can step on the other work and vice-versa, we decided to focus on completeness first, and then after that has been achieved, re-adapt and land the optimization work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nikomatsakis&quot;&gt;@nikomatsakis&lt;/a&gt; did a presentation on Polonius at RustBelt Rust. &lt;a href=&quot;https://nikomatsakis.github.io/rust-belt-rust-2019/&quot;&gt;Slides&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/albins&quot;&gt;@albins&lt;/a&gt; has finished their master's thesis and is currently rewriting most of the &lt;a href=&quot;https://rust-lang.zulipchat.com/user_uploads/4715/ufu5BGNrkzVbV8FtkK3Tco6M/Albins-Thesis-draft-version.pdf&quot;&gt;draft&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We hope to have a &amp;quot;polonius work week&amp;quot; at the end of November to push the in-progress work over the finish line together.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-self-profile&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-self-profile&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/self-profile/&quot;&gt;wg-self-profile&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We've nearly completed our long standing MVP goal!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mark-simulacrum&quot;&gt;@simulacrum&lt;/a&gt; has done some nice work to polish the integration with perf.rlo&lt;/li&gt;
&lt;li&gt;We've added tracking for all the events we're aware of that should be traced with the exception of trait selection.
&lt;ul&gt;
&lt;li&gt;We could really use some input as to what would be helpful to track!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/michaelwoerister&quot;&gt;@mw&lt;/a&gt; has been working on some changes to the binary format we record events in.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The new format is more compact so results in a smaller trace file and hopefully less runtime overhead.&lt;/li&gt;
&lt;li&gt;The new format is also more amenable to recording query keys, which is a highly requested feature.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wesleywiser&quot;&gt;@wesleywiser&lt;/a&gt; has added some crate level docs to make getting into the code easier.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wesleywiser&quot;&gt;@wesleywiser&lt;/a&gt; also added code to record process id, start time, and arguments to the trace file which we've started using.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/andjo403&quot;&gt;@andjo403&lt;/a&gt; has been a roll with a lot of great PRs!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We now have a dedicated tool for generating flamegraphs directly so you don't have to use the Perl scripts anymore.&lt;/li&gt;
&lt;li&gt;Some internal refactoring that makes adding new tools easier.&lt;/li&gt;
&lt;li&gt;Lots of work on the Chromium dev tools exporter:
&lt;ul&gt;
&lt;li&gt;New option to collapse disjoint threads so it's a little more manageable&lt;/li&gt;
&lt;li&gt;New option to filter out small events under a configurable threshold (necessary for very large compilations)&lt;/li&gt;
&lt;li&gt;You can now have multiple crate compilations in the same export file. This is similar to what cargo build -Z timings can do but much more detailed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-rls-20&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-rls-20&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/rls-2.0/&quot;&gt;wg-rls-2.0&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Work is procedding on splitting core of rust-analyzer into crates.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find usages is implemented.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Macro expansion now can map source ranges to expanded ranges, so goto def correctly goes &amp;quot;inside&amp;quot; macro call.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;More chalk an type inference work, specifically, support for closures.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There's ongoing discussion about the general planning about rustc, rls, and rust-analyzer.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Wesley Wiser</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-11-12 Infrastructure Team Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/18/infra-team-meeting.html" type="text/html" title="2019-11-12 Infrastructure Team Meeting" />
        <published>2019-11-18T00:00:00Z</published>
        <updated>2019-11-18T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/18/infra-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/18/infra-team-meeting.html">&lt;p&gt;Meeting run by pietroalbini. Minutes written by pietroalbini.
Attending: alexcrichton, kennytm, Mark-Simulacrum, pietroalbini, sgrif, shepmaster
&lt;a href=&quot;https://discordapp.com/channels/442252698964721669/443148319431065610/643872655312683018&quot;&gt;Start of the conversation&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rust-114.0-cargo-artifacts-on-the-rust-lang-ci-s3-bucket&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-114.0-cargo-artifacts-on-the-rust-lang-ci-s3-bucket&quot;&gt;&lt;/a&gt;Rust 1.14.0 Cargo artifacts on the rust-lang-ci S3 bucket&lt;/h2&gt;
&lt;p&gt;Following on last meeting’s topics, pietroalbini investigated whether it would
be possible to redirect requests for Cargo 1.14.0 from the &lt;code&gt;rust-lang-ci&lt;/code&gt; S3
bucket to our CDN. The answer is no, as the S3 support for redirects requires a
different endpoint than the one included in the manifest. The two main courses
of action were to do nothing (keeping the files in the &lt;code&gt;rust-lang-ci&lt;/code&gt; S3 bucket),
or to rewrite and resign the manifest of Rust 1.14.0 to point to the CDN.&lt;/p&gt;
&lt;p&gt;Mark-Simulacrum was in favor of doing nothing, but pietroalbini pointed out
keeping releases in two different places will make mirroring and caching
efforts more complex, as mirror authors will have to special-case a separate
domain just for a release. We then decided to rewrite and resign the manifest.&lt;/p&gt;
&lt;p&gt;shepmaster proposed to add a test somewhere to ensure this doesn’t happen
again, but nobody on the team had the time to do this. If someone is interested
please ask in the infra channel.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#deduplicating-ci-configuration-on-github-actions&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;deduplicating-ci-configuration-on-github-actions&quot;&gt;&lt;/a&gt;Deduplicating CI configuration on GitHub Actions&lt;/h2&gt;
&lt;p&gt;One issue about GitHub Actions is it doesn’t allow to include shared pieces of
configuration into workflows, forcing us to duplicate (for example) the steps
needed to complete a build. pietroalbini investigated a few ways to work around
the limitation, and the options he presented during the meeting are either
writing our own configuration format and having a tool generate the GitHub
Actions configuration from it, or duplicating the configuration manually and
having a tool to ensure the manually duplicated things don’t diverge.&lt;/p&gt;
&lt;p&gt;The rest of the team expressed concerns with generating the configuration, as
using the generator adds even more complexity to our already complex CI. On the
other hand pietroalbini didn’t like the tool to ensure the configuration
doesn’t diverge, as that would make changes to the CI configuration harder for
the people doing it. The agreement in the meeting is that pietroalbini will try
to create other proof of concepts, hoping to find a better solution.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#new-server-for-perf&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-server-for-perf&quot;&gt;&lt;/a&gt;New server for perf&lt;/h2&gt;
&lt;p&gt;alexcrichton didn’t hear back from Hetzner about the new perf server yet.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Evaluating GitHub Actions</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/14/evaluating-github-actions.html" type="text/html" title="Evaluating GitHub Actions" />
        <published>2019-11-14T00:00:00Z</published>
        <updated>2019-11-14T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/14/evaluating-github-actions.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/14/evaluating-github-actions.html">&lt;p&gt;The Rust Infrastructure team is happy to announce that we’re starting an
evaluation of &lt;a href=&quot;https://github.com/features/actions&quot;&gt;GitHub Actions&lt;/a&gt; as a
replacement for Azure Pipelines as the CI provider of the
&lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;rust-lang/rust&lt;/a&gt; repository.&lt;/p&gt;
&lt;p&gt;We’ve been part of the beta of GitHub Actions since the beginning, following
its development closely and testing it on a lot of smaller repositories in our
organization, and we’re really satisfied so far with the product. GitHub
Actions provides most of the features we love about Azure Pipelines, while
being integrated with GitHub’s UI, permissions and workflows.&lt;/p&gt;
&lt;p&gt;GitHub has also offered to sponsor a dedicated pool of builders with increased
resources. Our extensive but time-consuming CI is one of the major pain points
for compiler contributors, and the additional resources have the potential to
drastically improve our developers’ experience. We have achieved 60% faster
builds in preliminary testing thanks to the increased core count in the
dedicated builder pool, and there is still large room to parallelize and finish
builds even faster.&lt;/p&gt;
&lt;p&gt;Our plan is to start running GitHub Actions in parallel with Azure Pipelines in
the next few weeks, and we’ll keep the community updated as we learn more.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;[Update]&lt;/strong&gt; Some members of the community asked why we're considering to
switch away from Azure Pipelines so soon after migrating to it. We want to
reaffirm that we're happy with Pipelines as a product, but both Microsoft and
GitHub asked us to try GitHub Actions because it's more closely integrated into
the GitHub workflow that we already use. After we used it for a while in other
repositories we were satisfied enough to start evaluating a migration for
rustc's CI.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance WG Call For Participation</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/13/goverance-wg-cfp.html" type="text/html" title="Governance WG Call For Participation" />
        <published>2019-11-13T00:00:00Z</published>
        <updated>2019-11-13T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/13/goverance-wg-cfp.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/13/goverance-wg-cfp.html">&lt;p&gt;Hello everyone, the governance working group has been working a few efforts, but
we haven't made as much progress as we would have liked over the past few
months, so we are going to try out a new process and meeting agenda aimed at
trying to get more work done in the time we know we have.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#new-meeting-structure&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-meeting-structure&quot;&gt;&lt;/a&gt;New Meeting Structure&lt;/h2&gt;
&lt;p&gt;Previously we have been doing most of our work async while using our bi-weekly
meeting call to triage tasks. The problem we ran into with this is that a lot of
the members also heavy contributors to the Rust project as a whole, and it can
be can hard for some people to schedule time write an initial draft.&lt;/p&gt;
&lt;p&gt;To address this instead of triaging during the meeting and working on tasks in
async, we're going to hold focused topic based meetings, and use the time between
meetings, to publish posts like this and to research and prepare for the next
topic. To help do this we're going to extend our current meeting duration from
30 minutes to an hour. (The meeting will still be every two weeks.)&lt;/p&gt;
&lt;p&gt;The current goals are to documenting the de-facto governance structure, provide
the result as a RFC and then if merged provide a version on
&lt;a href=&quot;https://forge.rust-lang.org/&quot;&gt;forge.rust-lang.org&lt;/a&gt; so that it has greater visbility. We also want to
schedule people involved in Rust and other governance structures to come and
talk about their experiences.&lt;/p&gt;
&lt;p&gt;For deciding what topics, we're going to rotate who takes the lead for each
meeting. It's that person's responsibility to decide the topic and to
prepare a call for participation similar to this post informing people of
the topic and how they might best prepare if they wish to join.&lt;/p&gt;
&lt;p&gt;We also hope that having a focused topic will reduce any barrier of expected
knowledge in order to participate and contribute. With that said let's talk
about the topic for next meeting.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#reviewing--examining-previous-governance-rfcs&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;reviewing--examining-previous-governance-rfcs&quot;&gt;&lt;/a&gt;Reviewing &amp;amp; Examining Previous Governance RFCs&lt;/h2&gt;
&lt;p&gt;Our first topic for new meeting is going to be to read &lt;a href=&quot;https://rust-lang.github.io/rfcs/1068-rust-governance.html&quot;&gt;RFC 1068&lt;/a&gt;, the
original Rust Governance RFC, review how accurate it is to today's structure,
and see any if there are questions that we have that it doesn't answer. Here
are some other relevant RFCs for additional context:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/26197104b7bb9a5a35db243d639aee6e46d35d75/text/1728-north-star.md&quot;&gt;&amp;quot;North Star&amp;quot; RFC&lt;/a&gt; lays out the Rust roadmap process.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rust-lang.github.io/rfcs/2689-compiler-team-contributors.html&quot;&gt;Compiler contributors RFC&lt;/a&gt; details the process of contributing to the
compiler and progression towards joining the compiler team.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rust-lang.github.io/rfcs/1589-rustc-bug-fix-procedure.html&quot;&gt;Compiler bug fix procedure&lt;/a&gt; defines the best practices for making a bug fix
to the compiler.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our next meeting is going to be at &lt;strong&gt;22:00 UTC on Tuesday, November 19th&lt;/strong&gt;
and we'd like to encourage anyone who's interested, regardless of their
previous experience to read those RFCs and come to the &lt;code&gt;#wg-governance&lt;/code&gt;
channel on discord to attend the meeting. (Our meetings are done over a video
call with Zoom, but we use the discord channel to organise ourselves).&lt;/p&gt;
&lt;p&gt;If some reason you know you won't be able to attend these meetings but would
still like to participate. Please feel free to post any questions about Rust's
governance as &lt;a href=&quot;https://github.com/rust-lang/wg-governance/issues?q=is%3Aissue+is%3Aopen+label%3AQuestion&quot;&gt;issues on our GitHub repository&lt;/a&gt;, even if you are
not available to attend the working group's meetings.&lt;/p&gt;
</content>

        <author>
            <name>Erin Power</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-11-07 Compiler Team Triage Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/11/compiler-team-meeting.html" type="text/html" title="2019-11-07 Compiler Team Triage Meeting" />
        <published>2019-11-11T00:00:00Z</published>
        <updated>2019-11-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/11/compiler-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/11/compiler-team-meeting.html">&lt;p&gt;The compiler team had our weekly triage meeting on 2019-11-07.
You can find the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/minutes/triage-meeting/2019-11-07/&quot;&gt;minutes&lt;/a&gt; on the &lt;a href=&quot;https://github.com/rust-lang/compiler-team&quot;&gt;compiler-team&lt;/a&gt; repository.
Each week, we have general announcements from the team followed by check-ins from two of the compiler team working groups.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#announcements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;announcements&quot;&gt;&lt;/a&gt;Announcements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pnkfelix&quot;&gt;@pnkfelix&lt;/a&gt; is moving to the US and will be working in the Eastern timezone.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wesleywiser&quot;&gt;@wesleywiser&lt;/a&gt; has been working on the constant propagation pass and wants to &lt;a href=&quot;https://github.com/rust-lang/rust/pull/66074&quot;&gt;turn it on&lt;/a&gt; for debug &amp;amp; release builds to improve compilation time.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rust 1.39 has shipped with &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; support and other goodies.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#working-group-sync&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;working-group-sync&quot;&gt;&lt;/a&gt;Working group sync&lt;/h2&gt;
&lt;br/&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-polonius&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-polonius&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/polonius/&quot;&gt;wg-polonius&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We ran out of time this week to have a check-in from this working group.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#wg-rfc-2229&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;wg-rfc-2229&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/rfc-2229/&quot;&gt;wg-rfc-2229&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This working group is currently on a pause.&lt;/p&gt;
</content>

        <author>
            <name>Wesley Wiser</name>
        </author>
    </entry>
    
</feed>
