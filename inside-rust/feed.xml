<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-12-18T10:56:00Z</updated>

    
    <entry>
        <title>Bisecting Rust Compiler Regressions with cargo-bisect-rustc</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/18/bisecting-rust-compiler.html" type="text/html" title="Bisecting Rust Compiler Regressions with cargo-bisect-rustc" />
        <published>2019-12-18T00:00:00Z</published>
        <updated>2019-12-18T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/18/bisecting-rust-compiler.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/18/bisecting-rust-compiler.html">&lt;p&gt;Let's say that you've just updated the Rust compiler version and have
tried to compile your application and see a failure that wasn't there
before. That's likely due to a regression in the compiler.  We've just
released
&lt;a href=&quot;https://github.com/rust-lang/cargo-bisect-rustc&quot;&gt;&lt;code&gt;cargo-bisect-rustc&lt;/code&gt;&lt;/a&gt;,
a tool that makes it super easy to find exactly when the regression
happened.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cargo-bisect-rustc&lt;/code&gt; automatically downloads rustc artifacts and tests
them against a project you provide until it finds the regression. At
minimum, it will identify the nightly release which triggered the
regression; but if the regression occurred in the last 168 days, it will
even figure out the exact PR, which is often very useful in helping us
fix the problem.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cargo-bisect-rustc&lt;/code&gt; was created originally by Mark Rousskov. I extended
it recently to make it easier to use.&lt;/p&gt;
&lt;p&gt;To install the tool run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cargo install cargo-bisect-rustc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#finding-a-regression&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;finding-a-regression&quot;&gt;&lt;/a&gt;Finding a regression&lt;/h2&gt;
&lt;p&gt;We are going to use &lt;a href=&quot;https://github.com/rust-lang/rust/issues/64945&quot;&gt;this &amp;quot;old&amp;quot; reported rustc
regression&lt;/a&gt; as an
example:&lt;/p&gt;
&lt;p&gt;Our application consists only of this file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;pub struct Slice&amp;lt;'a, T&amp;gt;(&amp;amp;'a [T]);

impl&amp;lt;'a, T: 'a&amp;gt; Slice&amp;lt;'a, T&amp;gt; {
    pub const EMPTY: Self = Slice ({
        let v: &amp;amp;[T] = &amp;amp;[];
        v
    });
}

fn main() {
    let s = Slice(&amp;amp;[1, 2]);
    assert!(s.0 != Slice::EMPTY.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we run &lt;code&gt;cargo bisect-rustc --end=2019-10-02&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since this bug was fixed on 2019-10-03, we're using 2019-10-02 as the
end We need to provide the end point for this particular example, given
that this bug was fixed on 2019-10-03, we're using 2019-10-02 as the end
point. If you don't provide an ending point it assumes that the end
point is today's nightly or your currently installed nightly. If you
don't provide a start point as we're doing it tries to find one by
regressing in time.  If you know if a failing starting point it would be
faster if you just provide that one.&lt;/p&gt;
&lt;p&gt;By default it will run &lt;code&gt;cargo build&lt;/code&gt; in the project and check whether or
not it fails. After finding a nightly that has regressed it is going to
automatically search for the commit that introduced the regression.&lt;/p&gt;
&lt;p&gt;Let's see the tool in action:&lt;/p&gt;
&lt;p&gt;The tool starts by downloading various nightly compilers, trying to find
a date when the program worked ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;checking nightly-2019-10-02
std for x86_64-unknown-linux-gnu: 172.87 MB / 172.87 MB [===============================================================================================================================================================] 100.00 % 10.67 MB/s uninstalling nightly-2019-10-02
checking nightly-2019-09-30
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once it has one failing and working point it starts bisecting ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std for x86_64-unknown-linux-gnu: 173.43 MB / 173.43 MB [===============================================================================================================================================================] 100.00 % 12.82 MB/s uninstalling nightly-2019-09-29
tested nightly-2019-09-29, got No
searched toolchains nightly-2019-09-28 through nightly-2019-09-30
regression in nightly-2019-09-30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once it finds a nightly, it starts to search the PRs that went into that
nightly build ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;looking for regression commit between 2019-09-30 and 2019-09-29
fetching commits from 488381ce9ef0ceabe83b73127c659e5d38137df0 to 8431f261dd160021b6af85916f161a13dd101ca0
...
searched toolchains 488381ce9ef0ceabe83b73127c659e5d38137df0 through 8431f261dd160021b6af85916f161a13dd101ca0
regression in 0bbab7d99dde8620604fb265706dc8bff20345a7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, when it finds the PR that broke the compiler, it generates a
bug report that you can copy and paste!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;==================================================================================
= Please open an issue on Rust's github repository                               =
= https://github.com/rust-lang/rust/issues/new                                   =
= Below you will find a text that would serve as a starting point of your report =
==================================================================================

# Regression found in the compiler

searched nightlies: from nightly-2019-09-28 to nightly-2019-09-30
regressed nightly: nightly-2019-09-30
searched commits: from https://github.com/rust-lang/rust/commit/488381ce9ef0ceabe83b73127c659e5d38137df0 to https://github.com/rust-lang/rust/commit/8431f261dd160021b6af85916f161a13dd101ca0
regressed commit: https://github.com/rust-lang/rust/commit/0bbab7d99dde8620604fb265706dc8bff20345a7
source code: URL OF A REPOSITORY THAT REPRODUCES THE ERROR

## Instructions

Please give the steps for how to build your repository (platform, system dependencies, etc.)
## Error

&amp;lt;details&amp;gt;&amp;lt;summary&amp;gt;COLLAPSIBLE ERROR STACKTRACE&amp;lt;/summary&amp;gt;
&amp;lt;p&amp;gt;

```bash
Paste the error the compiler is giving
```

&amp;lt;/p&amp;gt;&amp;lt;/details&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This tells us that the regression started with
&lt;a href=&quot;https://github.com/rust-lang/rust/commit/0bbab7d99dde8620604fb265706dc8bff20345a7&quot;&gt;&lt;code&gt;0bbab7d99dde8620604fb265706dc8bff20345a7&lt;/code&gt;&lt;/a&gt;
and you can look at the git log to find the PR. In this case is
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/64470&quot;&gt;#64470&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#call-for-action-try-the-tool&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;call-for-action-try-the-tool&quot;&gt;&lt;/a&gt;Call for action: try the tool&lt;/h2&gt;
&lt;p&gt;Please, give this tool a try and if you find yourself updating your
application and it stops building, it's likely that you're hitting a
regression. As you can see at the end of the execution of the tool, if a
regression is found the tool gives you a report that you can paste on a
github issue on the &lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;Rust repo&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#call-for-action-get-involved-in-the-development-of-cargo-bisect-rustc&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;call-for-action-get-involved-in-the-development-of-cargo-bisect-rustc&quot;&gt;&lt;/a&gt;Call for action: get involved in the development of cargo-bisect-rustc&lt;/h2&gt;
&lt;p&gt;There are also a lot of things to improve in the tool and a lot of bugs
to fix. There are a bunch of reported issues that are easy to fix,
&lt;a href=&quot;https://github.com/rust-lang/cargo-bisect-rustc/issues&quot;&gt;check them
out&lt;/a&gt;.  You can
also, reach us out. You can find me and the rest of the compiler
contributors and members in &lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/217417-t-compiler.2Fcargo-bisect-rustc&quot;&gt;Zulip's #t-compiler/cargo-bisect-rustc
stream&lt;/a&gt;.
Sign up there if you haven't already and do not hesitate to ask
questions or even to send me a direct message if you don't know where to
start.&lt;/p&gt;
</content>

        <author>
            <name>Santiago Pastorino</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-12-10 Infrastructure Team Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/11/infra-team-meeting.html" type="text/html" title="2019-12-10 Infrastructure Team Meeting" />
        <published>2019-12-11T00:00:00Z</published>
        <updated>2019-12-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/11/infra-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/11/infra-team-meeting.html">&lt;p&gt;Meeting run by pietroalbini. Minutes written by pietroalbini.&lt;br /&gt;
Attending: aidanhs, kennytm, Mark-Simulacrum, pietroalbini, shepmaster&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#feedback-on-the-rfc-2837-draft&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;feedback-on-the-rfc-2837-draft&quot;&gt;&lt;/a&gt;Feedback on the RFC 2837 draft&lt;/h2&gt;
&lt;p&gt;pietroalbini gave the team a draft of &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2837&quot;&gt;RFC
2837&lt;/a&gt; (then published shortly
after the meeting), about the demotion of Apple 32bit targets to Tier 3 from
Tier 1 and 2 (see the RFC for the motivations leading to that). The team was
largely onboard with it, and everyone gave useful feedback, which was
incorporated into the RFC text. Kinnison also jumped in to clarify the rustup
behavior when a target is removed.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance Working Group Update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/10/governance-wg-meeting.html" type="text/html" title="Governance Working Group Update" />
        <published>2019-12-10T00:00:00Z</published>
        <updated>2019-12-10T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/10/governance-wg-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/10/governance-wg-meeting.html">&lt;p&gt;Hello everyone! The governance working group met last week to discuss
writing out a policy for access privileges on our Github
repositories. This blog post summarizes that meeting and also
announces the topic of our next meeting, which takes place on Tuesday,
December 17, 2019 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MnNuZDc0NzkzYTBkcDNzY2FkbWgzNjk3a2hfMjAxOTEyMTdUMjIwMDAwWiBtb3ppbGxhLmNvbV85YzZmYzNsNmJoZzhiY3A4Y2FmcnZrM29mNEBn&amp;tmsrc=mozilla.com_9c6fc3l6bhg8bcp8cafrvk3of4%40group.calendar.google.com&amp;scp=ALL&quot;&gt;calendar event&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Also, this week we have a &lt;a href=&quot;https://youtu.be/CyYwretwM8E&quot;&gt;video recording
available&lt;/a&gt;. (We're going to generally
try and record meetings when possible.)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#next-meeting&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;next-meeting&quot;&gt;&lt;/a&gt;Next meeting&lt;/h2&gt;
&lt;p&gt;The next meeting will be discussing project groups and their integration into
the lang team. This is building on a few different posts and ideas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XAMPPRocky's draft RFC &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/draft-rfcs/working-group-terminology.md&quot;&gt;clarifying our terminology around working groups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;My &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/09/11/aic-shepherds-3-0/&quot;&gt;Shepherds 3.0&lt;/a&gt; blog post&lt;/li&gt;
&lt;li&gt;The embedded working group's &lt;a href=&quot;https://github.com/rust-embedded/wg/pull/378&quot;&gt;shepherded projects RFC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;My recent blog post about &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/12/03/aic-improving-the-pre-rfc-process/&quot;&gt;an improved pre-RFC
process&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#access-rights-policy&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;access-rights-policy&quot;&gt;&lt;/a&gt;Access rights policy&lt;/h2&gt;
&lt;p&gt;I'll summarize our conclusions here. Consult the &lt;a href=&quot;https://github.com/rust-lang/wg-governance/&quot;&gt;wg-governance&lt;/a&gt;
repository to find more &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/minutes/2019.12.03.md&quot;&gt;detailed minutes&lt;/a&gt; from our conversation.
The key conclusions were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Where possible, we should stick to a single org (&lt;a href=&quot;https://github.com/rust-community/&quot;&gt;&lt;code&gt;rust-lang&lt;/code&gt;&lt;/a&gt;).
&lt;ul&gt;
&lt;li&gt;In particular, team-specific organizations like
&lt;a href=&quot;https://github.com/rust-dev-tools/&quot;&gt;&lt;code&gt;rust-dev-tools&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-community/&quot;&gt;&lt;code&gt;rust-community&lt;/code&gt;&lt;/a&gt; ought to be merged
into &lt;a href=&quot;https://github.com/rust-community/&quot;&gt;&lt;code&gt;rust-lang&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Using a single organization makes it much easier to administrate.&lt;/li&gt;
&lt;li&gt;Note that we've already deprecated the &lt;a href=&quot;https://github.com/rust-lang-nursery/&quot;&gt;&lt;code&gt;rust-lang-nursery&lt;/code&gt;&lt;/a&gt; org&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;As an exception, we will for now continue having each domain working group
operate outside of its own org (e.g., &lt;a href=&quot;https://github.com/rust-embedded/wg&quot;&gt;&lt;code&gt;rust-embedded&lt;/code&gt;&lt;/a&gt;). Those orgs
are quite active and have a diverse membership and we don't want to
disturb that for now.
&lt;ul&gt;
&lt;li&gt;However, it would be good if each such org added the &lt;code&gt;rust-lang-owner&lt;/code&gt; bot
as an owner, so that the rust infra team has access.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For repositories, we will avoid giving access to individuals, and instead try to
give access only to entities (teams, working groups, etc) that are created and
managed by the Rust &lt;a href=&quot;https://github.com/rust-lang/team&quot;&gt;team&lt;/a&gt; repository.
&lt;ul&gt;
&lt;li&gt;In general, it is not recommended to give owner or admin access; write access suffices.&lt;/li&gt;
&lt;li&gt;(Unfortunately, read and triage access is often not sufficient for us.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We also enumerated a number of &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/minutes/2019.12.03.md#action-items&quot;&gt;action items&lt;/a&gt; to putting this policy
in to practice. We'll be revisiting the topic periodically to check on
progress.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Docs.rs Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/09/announcing-the-docsrs-team.html" type="text/html" title="Announcing the Docs.rs Team" />
        <published>2019-12-09T00:00:00Z</published>
        <updated>2019-12-09T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/09/announcing-the-docsrs-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/09/announcing-the-docsrs-team.html">&lt;p&gt;Today we're announcing a brand new team: The Docs.rs Team!&lt;/p&gt;
&lt;p&gt;Previously, &lt;a href=&quot;https://docs.rs/&quot;&gt;Docs.rs&lt;/a&gt; has been managed by the Rustdoc Team, as many of the initial concerns of
Docs.rs were shared by Rustdoc as Docs.rs was being brought into team maintainership. However, as
time went on, those concerns started to diverge more and more, and so did the people who contributed
to either tool.&lt;/p&gt;
&lt;p&gt;The new Docs.rs Team will be responsible for the operations and development for &lt;a href=&quot;https://docs.rs/&quot;&gt;Docs.rs&lt;/a&gt;, leaving
the Rustdoc Team to be responsible for the Rustdoc tool itself. &lt;a href=&quot;https://github.com/QuietMisdreavus&quot;&gt;@QuietMisdreavus&lt;/a&gt; will be leading
the new Docs.rs Team, leaving &lt;a href=&quot;https://github.com/GuillaumeGomez&quot;&gt;@GuillaumeGomez&lt;/a&gt; to lead the Rustdoc Team.&lt;/p&gt;
&lt;p&gt;Joining QuietMisdreavus on the Docs.rs Team is GuillaumeGomez, coordinating work between Rustdoc and
Docs.rs; &lt;a href=&quot;https://github.com/onur&quot;&gt;@onur&lt;/a&gt;, the original creator of Docs.rs; &lt;a href=&quot;https://github.com/pietroalbini&quot;&gt;@pietroalbini&lt;/a&gt;, who has coordinated work in
Docs.rs from the perspective of the Infrastrucure Team; and introducing &lt;a href=&quot;https://github.com/jyn514&quot;&gt;@jyn514&lt;/a&gt;, who has worked to
improve the developer experience of contributing to Docs.rs by converting the local development
configuration to use &lt;code&gt;docker-compose&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;To get involved with either team, join us on Discord! The Rustdoc Team hangs out in &lt;a href=&quot;https://discord.gg/4yEYPuT&quot;&gt;&lt;code&gt;#rustdoc&lt;/code&gt;&lt;/a&gt;,
and the Docs.rs Team hangs out in &lt;a href=&quot;https://discord.gg/2k5vVWn&quot;&gt;&lt;code&gt;#docs-rs&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>QuietMisdreavus</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-11-18 IDE team meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/04/ide-future.html" type="text/html" title="2019-11-18 IDE team meeting" />
        <published>2019-12-04T00:00:00Z</published>
        <updated>2019-12-04T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/04/ide-future.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/04/ide-future.html">&lt;p&gt;Meeting run by nikomatsakis. Minutes written by nikomatsakis.
Attending: nikomatsakis, pnkfelix, Xanewok, matklad
&lt;a href=&quot;https://hackmd.io/fAnj6pNqRRGIyDQ4el5tcQ&quot;&gt;Notes&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#the-rust-ide&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-rust-ide&quot;&gt;&lt;/a&gt;The Rust IDE&lt;/h1&gt;
&lt;p&gt;In the last compiler/IDE team meeting we've discussed the overall direction for IDE support in Rust.&lt;/p&gt;
&lt;p&gt;At the moment, the two IDEs developed as part of the Rust project are Rust Language Server (RLS) and rust-analyzer.
The former is currently being shipped with the Rust distribution while the latter serves as a foundation for the &amp;quot;RLS 2.0&amp;quot; working group.&lt;/p&gt;
&lt;p&gt;Unfortunately, these are actively developed in separation without much code-sharing between the two.
We'd like to change that and to find out how we can unify these efforts.
Therefore, we've been having a series of talks with the aim of elaborating the design space and creating a proposal for how to improve the situation going forward.&lt;/p&gt;
&lt;p&gt;This blog post gives a short summary from our most recent meeting.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#why-2-ides&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;why-2-ides&quot;&gt;&lt;/a&gt;Why 2 IDEs?&lt;/h1&gt;
&lt;p&gt;The main benefits of rust-analyzer is greater performance (because of fully-lazy compilation model) and somewhat richer feature-set (due to more flexible analysis API).
The main benefits of RLS is precision (it uses &lt;code&gt;rustc&lt;/code&gt; under the hood).
Additionally, RLS is the main consumer of save-analysis infrastructure, which is a good fit for tools which need a static view of the codebase, such as &lt;a href=&quot;https://github.com/rust-dev-tools/cargo-src&quot;&gt;cargo-src&lt;/a&gt; or &lt;a href=&quot;https://code.visualstudio.com/blogs/2019/02/19/lsif&quot;&gt;lsif&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#save-analysis&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;save-analysis&quot;&gt;&lt;/a&gt;Save-analysis&lt;/h1&gt;
&lt;p&gt;What is &amp;quot;save-analysis&amp;quot;?
It is an unstable format which rustc uses to record information about the compiled code.
It contains a pretty high-level information.
For example, for each identifier in the source-crate, save-analyzer will map this identifier to a definition and list of usages.
&lt;code&gt;env RUSTFLAGS=&amp;quot;-Zunstable-options -Zsave-analysis&amp;quot; cargo check&lt;/code&gt; can be used to instruct &lt;code&gt;rustc&lt;/code&gt; to produce save-analysis files (in JSON format).
Because save-analysis is produced directly from rustc iternal data structures, it is guaranteed to be correct (modulo bugs in rustc itself).&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#query-model&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;query-model&quot;&gt;&lt;/a&gt;Query model&lt;/h1&gt;
&lt;p&gt;The fundamental problem with save-analysis is that it is computed for the whole crate at once.
This is pretty slow for non-trivial crates, and is also wasteful.
At any given moment in time, only a small fraction of analysis information is really required.
rust-analyzer solves this by using &lt;a href=&quot;https://github.com/salsa-rs/salsa&quot;&gt;&lt;code&gt;salsa&lt;/code&gt;&lt;/a&gt; queries for code analysis.
The result is a compilation model which is fully lazy across the whole crate graph.
This model is similar to what rustc is using internally, but is more lazy both &amp;quot;vertically&amp;quot; and &amp;quot;horizontally&amp;quot;.
Vertically, &lt;code&gt;rustc&lt;/code&gt; starts to be incremental only after parsing and macro expansion; rust-analyzer is incremental on per-file basis.
Horizontally, &lt;code&gt;rustc&lt;/code&gt; compiles one crate at a time; rust-analyzer uses queries for the whole crate graph.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#way-forward&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;way-forward&quot;&gt;&lt;/a&gt;Way forward&lt;/h1&gt;
&lt;p&gt;Our current hypothesis is that it is possible to integrate both approaches without doubling the engineering effort.
Specifically, we will add an option to rust-analyzer to use save-analysis for find-usages and rename functionality.
That way, we'll get precise results for most important queries, without slowing down completion.
Unlike RLS, however, rust-analyzer will not link to rustc and instead will rely on cargo for running the compiler and producing save-analysis data.
If this approach works, we will consider freezing RLS and focusing fully on rust-analyzer.
Long term, the plan is to unify the save-analysis fallback path and the lazy analysis.&lt;/p&gt;
&lt;p&gt;In parallel to this RLS/rust-analyzer unification effort, we continue to pursue rustc library-ification, with a specific focus on traits solving (via chalk) and type inference.
&amp;quot;Library-ification&amp;quot; is a term we've been using for the process of extracting code out of rustc into re-usable libaries which can be shared by both rustc and rust-analyzer.
The goal is to use library-ification to gradually reduce the amount of duplicated code between rustc and rust-analyzer, with the goal of eventually either having a single code-base, or having the vast majority of the logic be shared.&lt;/p&gt;
</content>

        <author>
            <name>Aleksey Kladov, Igor Matuszewski</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance Working Group Update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/03/governance-wg-meeting.html" type="text/html" title="Governance Working Group Update" />
        <published>2019-12-03T00:00:00Z</published>
        <updated>2019-12-03T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/03/governance-wg-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/03/governance-wg-meeting.html">&lt;p&gt;Hello everyone! Two weeks ago the governance working group met. Here are the large issues we discussed and information on our next meeting.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Edit:&lt;/em&gt; This post was prepared last week but was accidentally not merged. Apologies for the short notice about the topic of this week's meeting! --nikomatsakis&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#large-issues-discussed&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;large-issues-discussed&quot;&gt;&lt;/a&gt;Large Issues Discussed&lt;/h2&gt;
&lt;p&gt;We reviewed the &lt;a href=&quot;https://rust-lang.github.io/rfcs/1068-rust-governance.html&quot;&gt;current governance RFC&lt;/a&gt; and noted governance items that have been added since the RFC was written. We also noted things that have changed or have just not happened, as well as things that could be improved. Please see the &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/minutes/2019.11.19.md&quot;&gt;full notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#next-meeting&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;next-meeting&quot;&gt;&lt;/a&gt;Next Meeting&lt;/h2&gt;
&lt;p&gt;Next meeting will be at &lt;strong&gt;22:00 UTC on Tuesday, December 3&lt;/strong&gt; and will be focused on the need for a &lt;a href=&quot;https://github.com/rust-lang/wg-governance/issues/4&quot;&gt;GitHub Access Policy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We'd like to encourage anyone who's interested, regardless of their
previous experience to come to the &lt;code&gt;#wg-governance&lt;/code&gt;
channel on Discord to attend the meeting. (Our meetings are done over a video
call with Zoom, but we use the Discord channel to organise ourselves).&lt;/p&gt;
&lt;p&gt;If there are other issues you would like to see us discuss or discuss with us, please mention them in a comment on &lt;a href=&quot;https://github.com/rust-lang/wg-governance/issues/29&quot;&gt;this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Nell Shamrell-Harrington</name>
        </author>
    </entry>
    
    <entry>
        <title>Constant propagation is now on by default in nightly</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html" type="text/html" title="Constant propagation is now on by default in nightly" />
        <published>2019-12-02T00:00:00Z</published>
        <updated>2019-12-02T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html">&lt;p&gt;I'm pleased to announce that the &lt;a href=&quot;https://blog.rust-lang.org/2016/04/19/MIR.html&quot;&gt;Mid-level IR&lt;/a&gt; (MIR) constant propagation pass has been &lt;a href=&quot;https://github.com/rust-lang/rust/pull/66074&quot;&gt;switched on&lt;/a&gt; by default on Rust nightly which will eventually become Rust 1.41!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#what-is-constant-propagation&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-is-constant-propagation&quot;&gt;&lt;/a&gt;What is constant propagation?&lt;/h2&gt;
&lt;p&gt;Constant propagation is an optimization where the compiler recognizes code that can be run at compile time, evaluates it, and replaces the original code with the result.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const X: u32 = 2;

let y = X + X;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rather than evaluating &lt;code&gt;X + X&lt;/code&gt; at runtime, the compiler can recognize that the value of &lt;code&gt;X&lt;/code&gt; is known at compile time and replace it with the correct value resulting in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const X: u32 = 2;

let y = 4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This optimization is opportunistic and automatically recognizes constants even when they are not declared as such:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;struct Point {
  x: u32,
  y: u32,
}

let a = 2 + 2; // optimizes to 4
let b = [0, 1, 2, 3, 4, 5][3]; // optimizes to 3
let c = (Point { x: 21, y: 42 }).y; // optimizes to 42
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#propagation-into-control-flow&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;propagation-into-control-flow&quot;&gt;&lt;/a&gt;Propagation into control flow&lt;/h2&gt;
&lt;p&gt;The constant propagation pass also handles propagating into control flow.
For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const Foo: Option&amp;lt;u8&amp;gt; = Some(12);

let x = match Foo {
   None =&amp;gt; panic!(&amp;quot;no value&amp;quot;),
   Some(v) =&amp;gt; v,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;becomes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const Foo: Option&amp;lt;u8&amp;gt; = Some(12);

let x = 12;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is very helpful for checked math, the default in &lt;code&gt;debug&lt;/code&gt; mode, which introduces additional control flow after every operation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let x = 2 + 4 * 6;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;actually operates like this with overflow checking enabled:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let (_tmp0, overflowed) = CheckedMultiply(4, 6);
assert!(!overflowed, &amp;quot;attempt to multiply with overflow&amp;quot;);

let (_tmp1, overflowed) = CheckedAdd(_tmp0, 2);
assert!(!overflowed, &amp;quot;attempt to add with overflow&amp;quot;);

let x = _temp1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which adds quite a bit of control flow!
Constant propagation evaluates the math at compile time and reduces this to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let _tmp0 = 24;
assert!(!false, &amp;quot;attempt to multiply with overflow&amp;quot;);

let _tmp1 = 26;
assert!(!false, &amp;quot;attempt to add with overflow&amp;quot;);

let x = 26;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which is further reduced to just:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let x = 26;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#compiler-performance&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;compiler-performance&quot;&gt;&lt;/a&gt;Compiler performance&lt;/h2&gt;
&lt;p&gt;As you might have guessed, reducing the amount of control flow processed by the Rust compiler has a positive effect on compile times.
We're seeing 2-10% improvement on a variety of test cases in both debug and release mode.
Even though LLVM has its own constant propagation pass, we see improvements because our pass operates on MIR while it is still generic.
The more concrete instances of a generic function that are instantiated, the larger the payoff from this optimization.&lt;/p&gt;
&lt;p&gt;We've suspected for a while that the verbose LLVM IR the Rust compiler generates contributes considerably to long compilation times.
By implementing optimizations like this, we believe there is significant potential to lower compile times by generating better LLVM IR.
If you'd like to get involved with the MIR Optimizations working group, stop by our &lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/189540-t-compiler.2Fwg-mir-opt&quot;&gt;Zulip channel&lt;/a&gt; and say hello!&lt;/p&gt;
</content>

        <author>
            <name>Wesley Wiser</name>
        </author>
    </entry>
    
    <entry>
        <title>`if` and `match` in constants on nightly rust</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/25/const-if-match.html" type="text/html" title="`if` and `match` in constants on nightly rust" />
        <published>2019-11-25T00:00:00Z</published>
        <updated>2019-11-25T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/25/const-if-match.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/25/const-if-match.html">&lt;p&gt;&lt;strong&gt;TLDR; &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt; are now usable in constants on the latest nightly.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As a result, you can now write code like the following and have it execute at
compile-time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;static PLATFORM: &amp;amp;str = if cfg!(unix) {
    &amp;quot;unix&amp;quot;
} else if cfg!(windows) {
    &amp;quot;windows&amp;quot;
} else {
    &amp;quot;other&amp;quot;
};

const _: () = assert!(std::mem::size_of::&amp;lt;usize&amp;gt;() == 8, &amp;quot;Only 64-bit platforms are supported&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt; can also be used in the body of a &lt;code&gt;const fn&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const fn gcd(a: u32, b: u32) -&amp;gt; u32 {
    match (a, b) {
        (x, 0) | (0, x) =&amp;gt; x,

        (x, y) if x % 2 == 0 &amp;amp;&amp;amp; y % 2 == 0 =&amp;gt; 2*gcd(x/2, y/2),
        (x, y) | (y, x) if x % 2 == 0 =&amp;gt; gcd(x/2, y),

        (x, y) if x &amp;lt; y =&amp;gt; gcd((y-x)/2, x),
        (x, y) =&amp;gt; gcd((x-y)/2, y),
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#what-exactly-is-going-on-here&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-exactly-is-going-on-here&quot;&gt;&lt;/a&gt;What exactly is going on here?&lt;/h2&gt;
&lt;p&gt;The following expressions,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;if let&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;can now appear in any of the following contexts,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const fn&lt;/code&gt; bodies&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt; and associated &lt;code&gt;const&lt;/code&gt; initializers&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; and &lt;code&gt;static mut&lt;/code&gt; initializers&lt;/li&gt;
&lt;li&gt;array initializers&lt;/li&gt;
&lt;li&gt;const generics (EXPERIMENTAL)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if &lt;code&gt;#![feature(const_if_match)]&lt;/code&gt; is enabled for your crate.&lt;/p&gt;
&lt;p&gt;You may have noticed that the short-circuiting logic operators, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and
&lt;code&gt;||&lt;/code&gt;, were already legal in a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;. This was accomplished by
translating them to their non-short-circuiting equivalents, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;
respectively. Enabling the feature gate will turn off this hack and make &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;
and &lt;code&gt;||&lt;/code&gt; behave as you would expect.&lt;/p&gt;
&lt;p&gt;As a side-effect of these changes, the &lt;code&gt;assert&lt;/code&gt; and &lt;code&gt;debug_assert&lt;/code&gt; macros
become usable in a const context if &lt;code&gt;#![feature(const_panic)]&lt;/code&gt; is also
enabled. However, the other assert macros (e.g., &lt;code&gt;assert_eq&lt;/code&gt;,
&lt;code&gt;debug_assert_ne&lt;/code&gt;) remain forbidden, since they need to call &lt;code&gt;Debug::fmt&lt;/code&gt; on
their arguments.&lt;/p&gt;
&lt;p&gt;The looping constructs, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and &lt;code&gt;loop&lt;/code&gt; are also forbidden and will
be &lt;a href=&quot;https://github.com/rust-lang/rust/issues/52000&quot;&gt;feature-gated separately&lt;/a&gt;. As you have seen above, loops can be
emulated with recursion as a temporary measure. However, the non-recursive
version will usually be more efficient since rust does not (to my knowledge)
do tail call optimization.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;code&gt;?&lt;/code&gt; operator remains forbidden in a const context, since its
desugaring contains a call to &lt;code&gt;From::from&lt;/code&gt;. The design for &lt;code&gt;const&lt;/code&gt; trait
methods is still being discussed, and both &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;, which desugars to a
call to &lt;code&gt;IntoIterator::into_iter&lt;/code&gt;, will not be usable until a final decision is
reached.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-next?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-next?&quot;&gt;&lt;/a&gt;What's next?&lt;/h2&gt;
&lt;p&gt;This change will allow a great number of standard library functions to be made
&lt;code&gt;const&lt;/code&gt;. You can help with this process! To get started, here's a &lt;a href=&quot;https://github.com/rust-lang/rust/issues/53718&quot;&gt;list of
numeric functions&lt;/a&gt; that can be constified with little effort.
Conversion to a &lt;code&gt;const fn&lt;/code&gt; requires two steps. First, &lt;code&gt;const&lt;/code&gt; is added to a
function definition along with a &lt;code&gt;#[rustc_const_unstable]&lt;/code&gt; attribute. This
allows nightly users to call it in a const context. Then, after a period of
experimentation, the attribute is removed and the constness of that function is
stabilized. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/61635&quot;&gt;#61635&lt;/a&gt; for an example of the first step and &lt;a href=&quot;https://github.com/rust-lang/rust/pull/64028&quot;&gt;#64028&lt;/a&gt; for an
example of the second.&lt;/p&gt;
&lt;p&gt;Personally, I've looked forward to this feature for a long time, and I can't
wait to start playing with it. If you feel the same, I would greatly
appreciate if you tested the limits of this feature! Try to sneak &lt;code&gt;Cell&lt;/code&gt;s and
types with &lt;code&gt;Drop&lt;/code&gt; impls into places they shouldn't be allowed, blow up the
stack with poorly implemented recursive functions (see &lt;code&gt;gcd&lt;/code&gt; above), and let
us know if something goes horribly wrong.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#what-took-you-so-long&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-took-you-so-long&quot;&gt;&lt;/a&gt;What took you so long?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.github.io/rustc-guide/miri.html&quot;&gt;The Miri engine&lt;/a&gt;, which rust uses under the hood for compile-time
function evaluation, has been capable of this for a while now. However, rust
needs to statically guarantee certain properties about variables in a &lt;code&gt;const&lt;/code&gt;,
such as whether they allow for interior mutability or whether they have a
&lt;code&gt;Drop&lt;/code&gt; implementation that needs to be called. For example, we must reject the
following code since it would result in a &lt;code&gt;const&lt;/code&gt; being mutable at runtime!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const CELL: &amp;amp;std::cell::Cell&amp;lt;i32&amp;gt; = &amp;amp;std::cell::Cell::new(42); // Not allowed...

fn main() {
    CELL.set(0);
    println!(&amp;quot;{}&amp;quot;, CELL.get()); // otherwise this could print `0`!!!
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, it is sometimes okay for a &lt;code&gt;const&lt;/code&gt; to contain a reference to a &lt;em&gt;type&lt;/em&gt;
that may have interior mutability, as long as we can prove that the actual
&lt;em&gt;value&lt;/em&gt; of that type does not. This is particularly useful for &lt;code&gt;enum&lt;/code&gt;s with a
&amp;quot;unit variant&amp;quot; (e.g., &lt;code&gt;Option::None&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const NO_CELL: Option&amp;lt;&amp;amp;std::cell::Cell&amp;lt;i32&amp;gt;&amp;gt; = None; // OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A more detailed (but non-normative) treatment of the rules &lt;a href=&quot;https://github.com/rust-lang/const-eval/blob/master/static.md#drop&quot;&gt;for &lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;
and &lt;a href=&quot;https://github.com/rust-lang/const-eval/blob/master/const.md#2-interior-mutability&quot;&gt;for interior mutability&lt;/a&gt; in a const context can be found
on the &lt;a href=&quot;https://github.com/rust-lang/const-eval&quot;&gt;&lt;code&gt;const-eval&lt;/code&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;p&gt;It is not trivial to guarantee properties about the value of a variable when
complex control flow such as loops and conditionals is involved. Implementing
this feature required extending the existing dataflow framework in rust so
that we could properly track the value of each local across the control-flow
graph. At the moment, the analysis is very conservative, especially when values are
moved in and out of compound data types. For example, the following will not
compile, even when the feature gate is enabled.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const fn imprecise() -&amp;gt; Vec&amp;lt;i32&amp;gt; {
    let tuple: (Vec&amp;lt;i32&amp;gt;,) = (Vec::new(),);
    tuple.0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the &lt;code&gt;Vec&lt;/code&gt; created by &lt;code&gt;Vec::new&lt;/code&gt; will never actually be dropped
inside the &lt;code&gt;const fn&lt;/code&gt;, we don't detect that all fields of &lt;code&gt;tuple&lt;/code&gt; have been moved
out of, and thus conservatively assume that the drop impl for &lt;code&gt;tuple&lt;/code&gt; will run.
While this particular case is trivial, there are other, more complex ones that
would require a more comprehensive solution. It is an open question how precise
we want to be here, since more precision means longer compile times, even for
users that have no need for more expressiveness.&lt;/p&gt;
</content>

        <author>
            <name>Dylan MacKenzie</name>
        </author>
    </entry>
    
    <entry>
        <title>Upcoming compiler-team design meetings</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/22/upcoming-compiler-team-design-meetings.html" type="text/html" title="Upcoming compiler-team design meetings" />
        <published>2019-11-22T00:00:00Z</published>
        <updated>2019-11-22T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/22/upcoming-compiler-team-design-meetings.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/22/upcoming-compiler-team-design-meetings.html">&lt;p&gt;In our &lt;a href=&quot;https://zulip-archive.rust-lang.org/131828tcompiler/03407planningmeeting20191122.html&quot;&gt;planning meeting today&lt;/a&gt;, the &lt;a href=&quot;https://www.rust-lang.org/governance/teams/compiler&quot;&gt;compiler team&lt;/a&gt; has scheduled our
next batch of upcoming design meetings. You can find the exact times
on the compiler team's &lt;a href=&quot;https://rust-lang.github.io/compiler-team/#meeting-calendar&quot;&gt;meeting calendar&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On Nov 29 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MjM3aGsxdXY0dHBybXBxZ3ZxOGp1ZjdicjEgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
&lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/213&quot;&gt;rust-lang/compiler-team#213&lt;/a&gt;, a proposal to extend rustc's data
structures to enable outside crates to experiment with building a
Rust REPL.&lt;/li&gt;
&lt;li&gt;On Dec 6 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MTByaTZsZG1pZGI1Y2RqdGZ1cHV2djNncTEgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
&lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/175&quot;&gt;rust-lang/compiler-team#175&lt;/a&gt;, which is a plan to modify the
&lt;code&gt;rustc_interface&lt;/code&gt; trait to enable end-to-end query support in the
compiler.&lt;/li&gt;
&lt;li&gt;On Dec 13 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MGxrb2p2cG9lNGFnYTIybWVtcGRoZzdjdmogNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
&lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/222&quot;&gt;rust-lang/compiler-team#222&lt;/a&gt;, which is a roadmap and strategy for
eventually merging rustc, &lt;a href=&quot;https://github.com/rust-analyzer/rust-analyzer/&quot;&gt;rust-analyzer&lt;/a&gt;, and the RLS into one
coherent set of projects.&lt;/li&gt;
&lt;li&gt;On Dec 20 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MW12ZWI4NW9zZ2s2dHRkbW5wbjdjMG43Zm8gNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
&lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/209&quot;&gt;rust-lang/compiler-team#209&lt;/a&gt;, which is a proposal to create a
&amp;quot;major changes process&amp;quot; for the compiler, to augment these design
meetings.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#did-you-know&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;did-you-know&quot;&gt;&lt;/a&gt;Did you know?&lt;/h3&gt;
&lt;p&gt;Most weeks, the compiler team has some sort of design meeting. These
meetings take place on Zulip and are open to all. Every 4 weeks, we do
a planning meeting to pick the next few meetings from the list of open
proposals. You can find &lt;a href=&quot;https://rust-lang.github.io/compiler-team/about/steering-meeting/&quot;&gt;more details about how the compiler-team
steering meeting process here&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-11-14 and 2019-11-21 Lang Team Triage Meetings</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/11/22/Lang-team-meeting.html" type="text/html" title="2019-11-14 and 2019-11-21 Lang Team Triage Meetings" />
        <published>2019-11-22T00:00:00Z</published>
        <updated>2019-11-22T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/11/22/Lang-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/11/22/Lang-team-meeting.html">&lt;p&gt;Since I apparently forgot to post a blog post last week, this blog
post covers two lang-team triage meetings: [2019-11-14] and
[2019-11-21]. Recordings from &lt;a href=&quot;https://youtu.be/0exyVhBmDW0&quot;&gt;both&lt;/a&gt; &lt;a href=&quot;https://youtu.be/X2z3CoV0OUM&quot;&gt;meetings&lt;/a&gt; are also available.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#updates-on-shepherded-items&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;updates-on-shepherded-items&quot;&gt;&lt;/a&gt;Updates on shepherded items&lt;/h2&gt;
&lt;p&gt;Here is a list of the &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/09/11/aic-shepherds-3-0/&quot;&gt;&amp;quot;shepherded items&amp;quot;&lt;/a&gt; that the lang team is
tracking, along with weekly updates on the latest developments.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/const-eval&quot;&gt;const-eval&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;there is progress towards extending the set of expressions
permitted in constants to include &lt;code&gt;&amp;amp;mut&lt;/code&gt; borrows, if/match, and
loops.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/project-ffi-unwind&quot;&gt;project-ffi-unwind&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;current status: currently evaluating whether &amp;quot;C&amp;quot; functions should
permit unwinding by default&lt;/li&gt;
&lt;li&gt;trying to get measurements of the impact on code size&lt;/li&gt;
&lt;li&gt;prototyped the plan in a rustc branch, but needs a few updates and to be executed
on a representative code base (likely Fuschia)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/57893&quot;&gt;Coherence can be bypassed by an indirect impl for a trait object&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;did a &lt;a href=&quot;https://github.com/rust-lang/rust/pull/66037#issuecomment-549575983&quot;&gt;crater run of the proposal&lt;/a&gt; but have only partially analyzed the impact&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;grammar working group — qmx
&lt;ul&gt;
&lt;li&gt;no updates this week&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt; type and fallback — centril
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=a16420f41bbd2496ed07c75cf048189e&quot;&gt;&lt;code&gt;!&lt;/code&gt; is stable on nightly!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#about-the-lang-team-meetings&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;about-the-lang-team-meetings&quot;&gt;&lt;/a&gt;About the lang-team meetings&lt;/h2&gt;
&lt;p&gt;The lang-team triage meetings are held weekly on Zoom (see our
&lt;a href=&quot;https://github.com/rust-lang/lang-team/#meeting-calendar&quot;&gt;meeting calendar&lt;/a&gt;). Anyone is welcome to come and observe. We make a
&amp;quot;best effort&amp;quot; to record the meetings though technical issues sometimes
intervene.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
</feed>
