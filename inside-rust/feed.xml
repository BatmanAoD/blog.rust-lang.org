<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-12-27T08:16:21Z</updated>

    
    <entry>
        <title>Formatting the compiler tree</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/23/formatting-the-compiler.html" type="text/html" title="Formatting the compiler tree" />
        <published>2019-12-23T00:00:00Z</published>
        <updated>2019-12-23T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/23/formatting-the-compiler.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/23/formatting-the-compiler.html">&lt;h2&gt;&lt;a href=&quot;#what-happened&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-happened&quot;&gt;&lt;/a&gt;What happened&lt;/h2&gt;
&lt;p&gt;We recently landed two PRs which together reformatted essentially all code in the compiler tree.&lt;/p&gt;
&lt;p&gt;The first one, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/65939&quot;&gt;#65939&lt;/a&gt;, contained the initial formatting infrastructure. We currently use &lt;code&gt;rustfmt&lt;/code&gt;
directly, pinned to a version specified in &lt;code&gt;src/stage0.txt&lt;/code&gt;. We expect to update it as needed, and
otherwise once per cycle (coinciding with the bootstrap bump, most likely).&lt;/p&gt;
&lt;p&gt;The second one which reformatted the majority of the codebase is &lt;a href=&quot;https://github.com/rust-lang/rust/pull/67540&quot;&gt;#67540&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This change landed with the following rustfmt config. Note that this this configuration is subject
to change (in particular, merge_derives may be removed in the future), but should be fairly stable.
Your editor should automatically pick this configuration up inside the rust-lang/rust repository (it
is located in the &lt;code&gt;rustfmt.toml&lt;/code&gt; file in the root).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version = &amp;quot;Two&amp;quot;
use_small_heuristics = &amp;quot;Max&amp;quot;
merge_derives = false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#how-to-use-formatting&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-to-use-formatting&quot;&gt;&lt;/a&gt;How to use formatting&lt;/h2&gt;
&lt;p&gt;You can reformat the repository with &lt;code&gt;x.py fmt&lt;/code&gt; and &lt;code&gt;x.py fmt --check&lt;/code&gt; to verify formatting; these
commands are unfortunately somewhat slow today. Tidy will also currently run the latter of these two
checks (&lt;code&gt;x.py fmt --check&lt;/code&gt;) internally, but this may change in the future if we can't improve the
speed of formatting the entire codebase.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#resolving-conflicts&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;resolving-conflicts&quot;&gt;&lt;/a&gt;Resolving conflicts&lt;/h2&gt;
&lt;p&gt;If you have an ongoing branch, you're likely to have merge conflicts. The following should help you
resolve them:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This should be the name of the remote for rust-lang/rust
git fetch upstream
# This rebases up to the bors merge right before formatting landed;
# it needs to be done manually.
git rebase -i 9b98af84c4aa66392236fff59c86da2130d46d46
# This rebases onto the formatting PR (given the previous command, only that).
# We tell git to resolve all conflicts in favor of your code (`-Xtheirs`),
# and the `--exec` command specifies that after each commit lands, it will be formatted.
# This command will fail if your PR has intermediary commits with syntax conflicts.
git rebase -i a916ac22b9f7f1f0f7aba0a41a789b3ecd765018 \
    --exec './x.py fmt &amp;amp;&amp;amp; git add -u &amp;amp;&amp;amp; git commit --amend' \
    # This exec is optional, and won't work if your intermediate commits don't build,
    # but it helps make sure that the formatting resolution didn't introduce any errors.
    # It's recommended to run it afterwards before pushing at least.
    --exec './x.py check' \
    -Xtheirs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This should mostly resolve conflicts correctly, but occasionally if you've edited something in
imports (a common case I've encountered) or otherwise this will not resolve quite right. Usually
though this will solve 99% of the problems and the rest can be fixed up manually afterwards.&lt;/p&gt;
</content>

        <author>
            <name>Mark Rousskov</name>
        </author>
    </entry>
    
    <entry>
        <title>An Update from WG-Learning</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/20/wg-learning-update.html" type="text/html" title="An Update from WG-Learning" />
        <published>2019-12-20T00:00:00Z</published>
        <updated>2019-12-20T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/20/wg-learning-update.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/20/wg-learning-update.html">&lt;h1&gt;&lt;a href=&quot;#an-update-from-wg-learning&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;an-update-from-wg-learning&quot;&gt;&lt;/a&gt;An update from WG-Learning&lt;/h1&gt;
&lt;p&gt;In our last post in &lt;a href=&quot;https://blog.rust-lang.org/inside-rust/2019/10/28/rustc-learning-working-group-introduction.html&quot;&gt;October&lt;/a&gt; we gave an overview what the Learning WG is
and what we are doing. We have made a lot of progress since that post, and we
have also held a meeting to decide what to work on next. So let's dig in...&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#work-completed&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;work-completed&quot;&gt;&lt;/a&gt;Work completed&lt;/h2&gt;
&lt;p&gt;We mentioned before that we are in the process of producing &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/&quot;&gt;rustc-guide&lt;/a&gt;
chapters from the &amp;quot;Compiler Lecture Series&amp;quot; videos. The goal is to try to
produce guide chapters that are approachable for beginners and give a good
foundation for exploring and hacking on the compiler.&lt;/p&gt;
&lt;p&gt;Recently, we merge a &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/salsa.html&quot;&gt;chapter&lt;/a&gt; on &lt;a href=&quot;https://crates.io/crates/salsa&quot;&gt;&lt;code&gt;salsa&lt;/code&gt;&lt;/a&gt; by &lt;code&gt;@Karrq&lt;/code&gt;.
&lt;code&gt;salsa&lt;/code&gt; is a crate that makes incremental computation easier. While it is not
used in &lt;code&gt;rustc&lt;/code&gt; itself, it is heavily inspired by it, and it is used by
&lt;a href=&quot;https://github.com/rust-analyzer/rust-analyzer&quot;&gt;&lt;code&gt;rust-analyzer&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We also collectively have been working on a chapter about &lt;a href=&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/type.Ty.html&quot;&gt;&lt;code&gt;ty::Ty&lt;/code&gt;&lt;/a&gt; and
the way that rustc represents types internally. You can find that PR
&lt;a href=&quot;https://github.com/rust-lang/rustc-guide/pull/530&quot;&gt;here&lt;/a&gt;. This has been a big effort for a few months now, and we are excited
to have this new chapter in the guide.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-next?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-next?&quot;&gt;&lt;/a&gt;What's next?&lt;/h2&gt;
&lt;p&gt;We just had a &lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/196385-t-compiler.2Fwg-learning/topic/planning.20meeting&quot;&gt;planning meeting&lt;/a&gt; to discuss what to work on next. The
guide has some long-standing holes and shortcomings that we would like to address.&lt;/p&gt;
&lt;p&gt;Specifically, the Learning WG decided that we wanted to pursue the following goals next:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write an overview chapter&lt;/li&gt;
&lt;li&gt;Gather source material for chapters on monomorphization and LLVM&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#overview-chapter&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;overview-chapter&quot;&gt;&lt;/a&gt;Overview chapter&lt;/h3&gt;
&lt;p&gt;One of the challenges with big software systems is understanding how everything
fits together. We have seen this problem come up with the rustc-guide; the chapters
tunnel down into a single part of the compiler, but it is hard to get a good
view of all the things that happen to a piece of code between lexing and linking.&lt;/p&gt;
&lt;p&gt;We want to remedy this problem by creating an Overview chapter that walks
through some example from the beginning of the compiler to the end of the
compiler at a high level.  We plan to put this chapter at the beginning of
(part 2 of) the guide, so that it guide readers as to what part of the
compilation they are reading about in the subsequent chapters.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#monomorphization-codegen,-llvm&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;monomorphization-codegen,-llvm&quot;&gt;&lt;/a&gt;Monomorphization, Codegen, LLVM&lt;/h3&gt;
&lt;p&gt;One of the biggest gaps in the guide currently is what happens to your code
after the MIR is produced. We have chapters on almost everything that happens
before that (though many of them are pretty slim), but we have almost nothing
after the MIR is produced, borrow checked, and optimized.&lt;/p&gt;
&lt;p&gt;In particular, after the MIR is optimized, we need to &lt;a href=&quot;https://rust-lang.github.io/rustc-guide/appendix/glossary.html&quot;&gt;monomorphize&lt;/a&gt; it,
produce LLVM IR from it, call LLVM to produce executable code, and then link
everything to form a final binary object.&lt;/p&gt;
&lt;p&gt;The Learning WG will work on collecting information to write chapters on these
topics.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#getting-involved&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;getting-involved&quot;&gt;&lt;/a&gt;Getting involved&lt;/h2&gt;
&lt;p&gt;Did any of this sound interesting to you? We would love for you to join us! You
can the Learning WG on the &lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/196385-t-compiler.2Fwg-learning&quot;&gt;&lt;code&gt;t-compiler/wg-learning&lt;/code&gt;&lt;/a&gt; stream on Zulip.
Feel free to stop by and ping us.&lt;/p&gt;
</content>

        <author>
            <name>mark-i-m</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-12-17 Infrastructure Team Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/20/infra-team-meeting.html" type="text/html" title="2019-12-17 Infrastructure Team Meeting" />
        <published>2019-12-20T00:00:00Z</published>
        <updated>2019-12-20T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/20/infra-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/20/infra-team-meeting.html">&lt;p&gt;Meeting run by pietroalbini. Minutes written by pietroalbini.&lt;br /&gt;
Attending: aidanhs, alexcrichton, kennytm, Mark-Simulacrum, pietroalbini,
shepmaster&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#spurious-chocolatey-failures&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;spurious-chocolatey-failures&quot;&gt;&lt;/a&gt;Spurious Chocolatey failures&lt;/h2&gt;
&lt;p&gt;Since a few days ago, Chocolatey started returning 503 error codes at random,
preventing some Windows CI runners from downloading MSYS2, and the tree was
closed to prevent the failures from affecting a bunch of PRs. There were a few
proposals on how to work around them, spanning from a proper mirroring
implementation to just a quick fix to get CI working again.&lt;/p&gt;
&lt;p&gt;After the discussion the team agreed to prioritize getting CI working
consistently rather than implement the correct solution from the start. aidanhs
is going to look into that during the weekend, if nobody else finishes the work
before.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#progress-on-moving-the-infrastructure-to-terraform&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;progress-on-moving-the-infrastructure-to-terraform&quot;&gt;&lt;/a&gt;Progress on moving the infrastructure to Terraform&lt;/h2&gt;
&lt;p&gt;In the past few months pietroalbini started exploring moving the configuration
of Rust’s AWS infrastructure to Terraform, to allow for better collaboration
and auditability. So far a few services have been moved over to Terraform, and
pietroalbini proposed in the meeting to evaluate moving dynamic applications
over to ECS and configure those with Terraform.&lt;/p&gt;
&lt;p&gt;alexcrichton brought up the point that pietroalbini is at the moment the only
person in the team familiar with our Terraform setup, and while it’s probably a
better solution than the status quo we need more people able to work with it
before we decide to fully commit to using it. He acknowledged the current
solution (services manually configured through the console) is not scalable nor
long term, but we can’t jump to Terraform if most of the team doesn’t know how
to work with it.&lt;/p&gt;
&lt;p&gt;shepmaster said that this is not much different than the situation in the past,
where alexcrichton was the only one knowing how our infrastructure worked
(since then other people in the team got up to speed). aidanhs pointed out that
we had a case in the past like that, when only alexcrichton knew how a system
worked and it broke while he was on holiday.&lt;/p&gt;
&lt;p&gt;alexcrichton proposed to pause investing time into Terraform until at least
another team member gets familiar with it, and Mark-Simulacrum said he’s
willing to pair with pietroalbini for a few hours to migrate one of the
services to Terraform, learning how it works in the process.&lt;/p&gt;
&lt;p&gt;The feelings about ECS turned up to be mostly the same: everyone agreed it’s
surely a better solution than the setup we have right now, but only
pietroalbini is familiar with it. We agreed that pietroalbini and
Mark-Simulacrum are going to deploy one of the small applications to ECS using
Terraform while pairing, testing both the new things in one go.&lt;/p&gt;
&lt;p&gt;In the end, pietroalbini reminded the team that not every application we
currently host is going to fit into ECS + Fargate without changes, especially
because you can’t really persist data on the filesystem with it, but he
mentioned he’s willing to do the implementation work to adapt those
applications not to use the filesystem anymore.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance Working Group Update: Meeting 17 December 2019</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/20/governance-wg-meeting.html" type="text/html" title="Governance Working Group Update: Meeting 17 December 2019" />
        <published>2019-12-20T00:00:00Z</published>
        <updated>2019-12-20T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/20/governance-wg-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/20/governance-wg-meeting.html">&lt;p&gt;Hello everyone!&lt;/p&gt;
&lt;p&gt;On Tuesday 17 December the working group met and built an outline of an RFC to introduce project groups. If you would like to watch, a recording is available on &lt;a href=&quot;https://www.youtube.com/watch?v=q6us8yhDDUU&amp;feature=youtu.be&quot;&gt;YouTube&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#project-groups&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;project-groups&quot;&gt;&lt;/a&gt;Project groups&lt;/h2&gt;
&lt;p&gt;You can see the &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/minutes/2019.12.17.md&quot;&gt;detailed minutes&lt;/a&gt; on the &lt;a href=&quot;https://github.com/rust-lang/wg-governance/&quot;&gt;wg-governance&lt;/a&gt; repository, but here is a quick summary of what we would like to do with the RFC:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Introduce the project group concept, creation workflow, and lifecycle&lt;/li&gt;
&lt;li&gt;Provide guidance for how project groups use RFCs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Goals served by introducing project groups include improved visibility into and follow-through on projects,
as well as supporting better documentation of the design process.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#next-meeting&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;next-meeting&quot;&gt;&lt;/a&gt;Next meeting&lt;/h2&gt;
&lt;p&gt;Our next meeting will be Jan 14. The topic is to be determined, but it is planned to discuss that on January 7th on the Rust Discord in the &lt;code&gt;#wg-governance&lt;/code&gt; channel.&lt;/p&gt;
</content>

        <author>
            <name>Val Grimm</name>
        </author>
    </entry>
    
    <entry>
        <title>Congrats to compiler team members matthewjasper and wesleywiser</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/19/jasper-and-wiser-full-members-of-compiler-team.html" type="text/html" title="Congrats to compiler team members matthewjasper and wesleywiser" />
        <published>2019-12-19T00:00:00Z</published>
        <updated>2019-12-19T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/19/jasper-and-wiser-full-members-of-compiler-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/19/jasper-and-wiser-full-members-of-compiler-team.html">&lt;p&gt;I am pleased to announce that &lt;a href=&quot;https://github.com/matthewjasper/&quot;&gt;@matthewjasper&lt;/a&gt; and &lt;a href=&quot;https://github.com/wesleywiser/&quot;&gt;@wesleywiser&lt;/a&gt;
have been made full members of the &lt;a href=&quot;https://www.rust-lang.org/governance/teams/compiler&quot;&gt;compiler team&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/matthewjasper/&quot;&gt;@matthewjasper&lt;/a&gt; has been a huge contributor to the Non-Lexical
Lifetimes (NLL) work, filing issues and fixing bugs starting way back in
2017. Matthew has also been fixing compiler soundness bugs and making
miscellaneous improvements to Rust's Middle Intermediate
Representation (MIR). Most recently, Matthew has removed all uses of
&lt;code&gt;gensym&lt;/code&gt; from the compiler, as well as the &lt;code&gt;gensym&lt;/code&gt; functionality
itself (which was implemented in a way that injected
&lt;a href=&quot;https://github.com/rust-lang/rust/issues/49300&quot;&gt;subtle bugs&lt;/a&gt; with incremental compilation).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wesleywiser/&quot;&gt;@wesleywiser&lt;/a&gt; first started contributing to Rust way back in 2015,
before even the 1.0 release, with various documentation &lt;a href=&quot;https://github.com/rust-lang/rust/pull/22633&quot;&gt;fixes&lt;/a&gt;.
Since then, Wesley has improved the incremental compilation system,
added MIR optimization passes like constant-propagation and inlining,
and has been part of the compiler's self-profiler effort, starting with its
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/51657&quot;&gt;first version&lt;/a&gt; and
continuing today as a co-lead of &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/self-profile/&quot;&gt;WG-self-profile&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Congratulations to both &lt;a href=&quot;https://github.com/matthewjasper/&quot;&gt;@matthewjasper&lt;/a&gt; and &lt;a href=&quot;https://github.com/wesleywiser/&quot;&gt;@wesleywiser&lt;/a&gt;, and thanks
for all of your contributions to the project!&lt;/p&gt;
</content>

        <author>
            <name>Felix S. Klock II</name>
        </author>
    </entry>
    
    <entry>
        <title>Bisecting Rust Compiler Regressions with cargo-bisect-rustc</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/18/bisecting-rust-compiler.html" type="text/html" title="Bisecting Rust Compiler Regressions with cargo-bisect-rustc" />
        <published>2019-12-18T00:00:00Z</published>
        <updated>2019-12-18T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/18/bisecting-rust-compiler.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/18/bisecting-rust-compiler.html">&lt;p&gt;Let's say that you've just updated the Rust compiler version and have
tried to compile your application and see a failure that wasn't there
before. That's likely due to a regression in the compiler.  We've just
released
&lt;a href=&quot;https://github.com/rust-lang/cargo-bisect-rustc&quot;&gt;&lt;code&gt;cargo-bisect-rustc&lt;/code&gt;&lt;/a&gt;,
a tool that makes it super easy to find exactly when the regression
happened.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cargo-bisect-rustc&lt;/code&gt; automatically downloads rustc artifacts and tests
them against a project you provide until it finds the regression. At
minimum, it will identify the nightly release which triggered the
regression; but if the regression occurred in the last 168 days, it will
even figure out the exact PR, which is often very useful in helping us
fix the problem.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cargo-bisect-rustc&lt;/code&gt; was created originally by Mark Rousskov. I extended
it recently to make it easier to use.&lt;/p&gt;
&lt;p&gt;To install the tool run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cargo install cargo-bisect-rustc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#finding-a-regression&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;finding-a-regression&quot;&gt;&lt;/a&gt;Finding a regression&lt;/h2&gt;
&lt;p&gt;We are going to use &lt;a href=&quot;https://github.com/rust-lang/rust/issues/64945&quot;&gt;this &amp;quot;old&amp;quot; reported rustc
regression&lt;/a&gt; as an
example:&lt;/p&gt;
&lt;p&gt;Our application consists only of this file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;pub struct Slice&amp;lt;'a, T&amp;gt;(&amp;amp;'a [T]);

impl&amp;lt;'a, T: 'a&amp;gt; Slice&amp;lt;'a, T&amp;gt; {
    pub const EMPTY: Self = Slice ({
        let v: &amp;amp;[T] = &amp;amp;[];
        v
    });
}

fn main() {
    let s = Slice(&amp;amp;[1, 2]);
    assert!(s.0 != Slice::EMPTY.0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we run &lt;code&gt;cargo bisect-rustc --end=2019-10-02&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since this bug was fixed on 2019-10-03, we're using 2019-10-02 as the
end We need to provide the end point for this particular example, given
that this bug was fixed on 2019-10-03, we're using 2019-10-02 as the end
point. If you don't provide an ending point it assumes that the end
point is today's nightly or your currently installed nightly. If you
don't provide a start point as we're doing it tries to find one by
regressing in time.  If you know if a failing starting point it would be
faster if you just provide that one.&lt;/p&gt;
&lt;p&gt;By default it will run &lt;code&gt;cargo build&lt;/code&gt; in the project and check whether or
not it fails. After finding a nightly that has regressed it is going to
automatically search for the commit that introduced the regression.&lt;/p&gt;
&lt;p&gt;Let's see the tool in action:&lt;/p&gt;
&lt;p&gt;The tool starts by downloading various nightly compilers, trying to find
a date when the program worked ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;checking nightly-2019-10-02
std for x86_64-unknown-linux-gnu: 172.87 MB / 172.87 MB [===============================================================================================================================================================] 100.00 % 10.67 MB/s uninstalling nightly-2019-10-02
checking nightly-2019-09-30
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once it has one failing and working point it starts bisecting ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;std for x86_64-unknown-linux-gnu: 173.43 MB / 173.43 MB [===============================================================================================================================================================] 100.00 % 12.82 MB/s uninstalling nightly-2019-09-29
tested nightly-2019-09-29, got No
searched toolchains nightly-2019-09-28 through nightly-2019-09-30
regression in nightly-2019-09-30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once it finds a nightly, it starts to search the PRs that went into that
nightly build ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;looking for regression commit between 2019-09-30 and 2019-09-29
fetching commits from 488381ce9ef0ceabe83b73127c659e5d38137df0 to 8431f261dd160021b6af85916f161a13dd101ca0
...
searched toolchains 488381ce9ef0ceabe83b73127c659e5d38137df0 through 8431f261dd160021b6af85916f161a13dd101ca0
regression in 0bbab7d99dde8620604fb265706dc8bff20345a7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, when it finds the PR that broke the compiler, it generates a
bug report that you can copy and paste!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;==================================================================================
= Please open an issue on Rust's github repository                               =
= https://github.com/rust-lang/rust/issues/new                                   =
= Below you will find a text that would serve as a starting point of your report =
==================================================================================

# Regression found in the compiler

searched nightlies: from nightly-2019-09-28 to nightly-2019-09-30
regressed nightly: nightly-2019-09-30
searched commits: from https://github.com/rust-lang/rust/commit/488381ce9ef0ceabe83b73127c659e5d38137df0 to https://github.com/rust-lang/rust/commit/8431f261dd160021b6af85916f161a13dd101ca0
regressed commit: https://github.com/rust-lang/rust/commit/0bbab7d99dde8620604fb265706dc8bff20345a7
source code: URL OF A REPOSITORY THAT REPRODUCES THE ERROR

## Instructions

Please give the steps for how to build your repository (platform, system dependencies, etc.)
## Error

&amp;lt;details&amp;gt;&amp;lt;summary&amp;gt;COLLAPSIBLE ERROR STACKTRACE&amp;lt;/summary&amp;gt;
&amp;lt;p&amp;gt;

```bash
Paste the error the compiler is giving
```

&amp;lt;/p&amp;gt;&amp;lt;/details&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This tells us that the regression started with
&lt;a href=&quot;https://github.com/rust-lang/rust/commit/0bbab7d99dde8620604fb265706dc8bff20345a7&quot;&gt;&lt;code&gt;0bbab7d99dde8620604fb265706dc8bff20345a7&lt;/code&gt;&lt;/a&gt;
and you can look at the git log to find the PR. In this case is
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/64470&quot;&gt;#64470&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#call-for-action-try-the-tool&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;call-for-action-try-the-tool&quot;&gt;&lt;/a&gt;Call for action: try the tool&lt;/h2&gt;
&lt;p&gt;Please, give this tool a try and if you find yourself updating your
application and it stops building, it's likely that you're hitting a
regression. As you can see at the end of the execution of the tool, if a
regression is found the tool gives you a report that you can paste on a
github issue on the &lt;a href=&quot;https://github.com/rust-lang/rust&quot;&gt;Rust repo&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#call-for-action-get-involved-in-the-development-of-cargo-bisect-rustc&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;call-for-action-get-involved-in-the-development-of-cargo-bisect-rustc&quot;&gt;&lt;/a&gt;Call for action: get involved in the development of cargo-bisect-rustc&lt;/h2&gt;
&lt;p&gt;There are also a lot of things to improve in the tool and a lot of bugs
to fix. There are a bunch of reported issues that are easy to fix,
&lt;a href=&quot;https://github.com/rust-lang/cargo-bisect-rustc/issues&quot;&gt;check them
out&lt;/a&gt;.  You can
also, reach us out. You can find me and the rest of the compiler
contributors and members in &lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/217417-t-compiler.2Fcargo-bisect-rustc&quot;&gt;Zulip's #t-compiler/cargo-bisect-rustc
stream&lt;/a&gt;.
Sign up there if you haven't already and do not hesitate to ask
questions or even to send me a direct message if you don't know where to
start.&lt;/p&gt;
</content>

        <author>
            <name>Santiago Pastorino</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-12-10 Infrastructure Team Meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/11/infra-team-meeting.html" type="text/html" title="2019-12-10 Infrastructure Team Meeting" />
        <published>2019-12-11T00:00:00Z</published>
        <updated>2019-12-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/11/infra-team-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/11/infra-team-meeting.html">&lt;p&gt;Meeting run by pietroalbini. Minutes written by pietroalbini.&lt;br /&gt;
Attending: aidanhs, kennytm, Mark-Simulacrum, pietroalbini, shepmaster&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#feedback-on-the-rfc-2837-draft&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;feedback-on-the-rfc-2837-draft&quot;&gt;&lt;/a&gt;Feedback on the RFC 2837 draft&lt;/h2&gt;
&lt;p&gt;pietroalbini gave the team a draft of &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2837&quot;&gt;RFC
2837&lt;/a&gt; (then published shortly
after the meeting), about the demotion of Apple 32bit targets to Tier 3 from
Tier 1 and 2 (see the RFC for the motivations leading to that). The team was
largely onboard with it, and everyone gave useful feedback, which was
incorporated into the RFC text. Kinnison also jumped in to clarify the rustup
behavior when a target is removed.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance Working Group Update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/10/governance-wg-meeting.html" type="text/html" title="Governance Working Group Update" />
        <published>2019-12-10T00:00:00Z</published>
        <updated>2019-12-10T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/10/governance-wg-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/10/governance-wg-meeting.html">&lt;p&gt;Hello everyone! The governance working group met last week to discuss
writing out a policy for access privileges on our Github
repositories. This blog post summarizes that meeting and also
announces the topic of our next meeting, which takes place on Tuesday,
December 17, 2019 (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=MnNuZDc0NzkzYTBkcDNzY2FkbWgzNjk3a2hfMjAxOTEyMTdUMjIwMDAwWiBtb3ppbGxhLmNvbV85YzZmYzNsNmJoZzhiY3A4Y2FmcnZrM29mNEBn&amp;tmsrc=mozilla.com_9c6fc3l6bhg8bcp8cafrvk3of4%40group.calendar.google.com&amp;scp=ALL&quot;&gt;calendar event&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Also, this week we have a &lt;a href=&quot;https://youtu.be/CyYwretwM8E&quot;&gt;video recording
available&lt;/a&gt;. (We're going to generally
try and record meetings when possible.)&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#next-meeting&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;next-meeting&quot;&gt;&lt;/a&gt;Next meeting&lt;/h2&gt;
&lt;p&gt;The next meeting will be discussing project groups and their integration into
the lang team. This is building on a few different posts and ideas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XAMPPRocky's draft RFC &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/draft-rfcs/working-group-terminology.md&quot;&gt;clarifying our terminology around working groups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;My &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/09/11/aic-shepherds-3-0/&quot;&gt;Shepherds 3.0&lt;/a&gt; blog post&lt;/li&gt;
&lt;li&gt;The embedded working group's &lt;a href=&quot;https://github.com/rust-embedded/wg/pull/378&quot;&gt;shepherded projects RFC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;My recent blog post about &lt;a href=&quot;http://smallcultfollowing.com/babysteps/blog/2019/12/03/aic-improving-the-pre-rfc-process/&quot;&gt;an improved pre-RFC
process&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#access-rights-policy&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;access-rights-policy&quot;&gt;&lt;/a&gt;Access rights policy&lt;/h2&gt;
&lt;p&gt;I'll summarize our conclusions here. Consult the &lt;a href=&quot;https://github.com/rust-lang/wg-governance/&quot;&gt;wg-governance&lt;/a&gt;
repository to find more &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/minutes/2019.12.03.md&quot;&gt;detailed minutes&lt;/a&gt; from our conversation.
The key conclusions were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Where possible, we should stick to a single org (&lt;a href=&quot;https://github.com/rust-community/&quot;&gt;&lt;code&gt;rust-lang&lt;/code&gt;&lt;/a&gt;).
&lt;ul&gt;
&lt;li&gt;In particular, team-specific organizations like
&lt;a href=&quot;https://github.com/rust-dev-tools/&quot;&gt;&lt;code&gt;rust-dev-tools&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/rust-community/&quot;&gt;&lt;code&gt;rust-community&lt;/code&gt;&lt;/a&gt; ought to be merged
into &lt;a href=&quot;https://github.com/rust-community/&quot;&gt;&lt;code&gt;rust-lang&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Using a single organization makes it much easier to administrate.&lt;/li&gt;
&lt;li&gt;Note that we've already deprecated the &lt;a href=&quot;https://github.com/rust-lang-nursery/&quot;&gt;&lt;code&gt;rust-lang-nursery&lt;/code&gt;&lt;/a&gt; org&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;As an exception, we will for now continue having each domain working group
operate outside of its own org (e.g., &lt;a href=&quot;https://github.com/rust-embedded/wg&quot;&gt;&lt;code&gt;rust-embedded&lt;/code&gt;&lt;/a&gt;). Those orgs
are quite active and have a diverse membership and we don't want to
disturb that for now.
&lt;ul&gt;
&lt;li&gt;However, it would be good if each such org added the &lt;code&gt;rust-lang-owner&lt;/code&gt; bot
as an owner, so that the rust infra team has access.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For repositories, we will avoid giving access to individuals, and instead try to
give access only to entities (teams, working groups, etc) that are created and
managed by the Rust &lt;a href=&quot;https://github.com/rust-lang/team&quot;&gt;team&lt;/a&gt; repository.
&lt;ul&gt;
&lt;li&gt;In general, it is not recommended to give owner or admin access; write access suffices.&lt;/li&gt;
&lt;li&gt;(Unfortunately, read and triage access is often not sufficient for us.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We also enumerated a number of &lt;a href=&quot;https://github.com/rust-lang/wg-governance/blob/master/minutes/2019.12.03.md#action-items&quot;&gt;action items&lt;/a&gt; to putting this policy
in to practice. We'll be revisiting the topic periodically to check on
progress.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Docs.rs Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/09/announcing-the-docsrs-team.html" type="text/html" title="Announcing the Docs.rs Team" />
        <published>2019-12-09T00:00:00Z</published>
        <updated>2019-12-09T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/09/announcing-the-docsrs-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/09/announcing-the-docsrs-team.html">&lt;p&gt;Today we're announcing a brand new team: The Docs.rs Team!&lt;/p&gt;
&lt;p&gt;Previously, &lt;a href=&quot;https://docs.rs/&quot;&gt;Docs.rs&lt;/a&gt; has been managed by the Rustdoc Team, as many of the initial concerns of
Docs.rs were shared by Rustdoc as Docs.rs was being brought into team maintainership. However, as
time went on, those concerns started to diverge more and more, and so did the people who contributed
to either tool.&lt;/p&gt;
&lt;p&gt;The new Docs.rs Team will be responsible for the operations and development for &lt;a href=&quot;https://docs.rs/&quot;&gt;Docs.rs&lt;/a&gt;, leaving
the Rustdoc Team to be responsible for the Rustdoc tool itself. &lt;a href=&quot;https://github.com/QuietMisdreavus&quot;&gt;@QuietMisdreavus&lt;/a&gt; will be leading
the new Docs.rs Team, leaving &lt;a href=&quot;https://github.com/GuillaumeGomez&quot;&gt;@GuillaumeGomez&lt;/a&gt; to lead the Rustdoc Team.&lt;/p&gt;
&lt;p&gt;Joining QuietMisdreavus on the Docs.rs Team is GuillaumeGomez, coordinating work between Rustdoc and
Docs.rs; &lt;a href=&quot;https://github.com/onur&quot;&gt;@onur&lt;/a&gt;, the original creator of Docs.rs; &lt;a href=&quot;https://github.com/pietroalbini&quot;&gt;@pietroalbini&lt;/a&gt;, who has coordinated work in
Docs.rs from the perspective of the Infrastrucure Team; and introducing &lt;a href=&quot;https://github.com/jyn514&quot;&gt;@jyn514&lt;/a&gt;, who has worked to
improve the developer experience of contributing to Docs.rs by converting the local development
configuration to use &lt;code&gt;docker-compose&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;To get involved with either team, join us on Discord! The Rustdoc Team hangs out in &lt;a href=&quot;https://discord.gg/4yEYPuT&quot;&gt;&lt;code&gt;#rustdoc&lt;/code&gt;&lt;/a&gt;,
and the Docs.rs Team hangs out in &lt;a href=&quot;https://discord.gg/2k5vVWn&quot;&gt;&lt;code&gt;#docs-rs&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>QuietMisdreavus</name>
        </author>
    </entry>
    
    <entry>
        <title>2019-11-18 IDE team meeting</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/12/04/ide-future.html" type="text/html" title="2019-11-18 IDE team meeting" />
        <published>2019-12-04T00:00:00Z</published>
        <updated>2019-12-04T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/12/04/ide-future.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/12/04/ide-future.html">&lt;p&gt;Meeting run by nikomatsakis. Minutes written by nikomatsakis.
Attending: nikomatsakis, pnkfelix, Xanewok, matklad
&lt;a href=&quot;https://hackmd.io/fAnj6pNqRRGIyDQ4el5tcQ&quot;&gt;Notes&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#the-rust-ide&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-rust-ide&quot;&gt;&lt;/a&gt;The Rust IDE&lt;/h1&gt;
&lt;p&gt;In the last compiler/IDE team meeting we've discussed the overall direction for IDE support in Rust.&lt;/p&gt;
&lt;p&gt;At the moment, the two IDEs developed as part of the Rust project are Rust Language Server (RLS) and rust-analyzer.
The former is currently being shipped with the Rust distribution while the latter serves as a foundation for the &amp;quot;RLS 2.0&amp;quot; working group.&lt;/p&gt;
&lt;p&gt;Unfortunately, these are actively developed in separation without much code-sharing between the two.
We'd like to change that and to find out how we can unify these efforts.
Therefore, we've been having a series of talks with the aim of elaborating the design space and creating a proposal for how to improve the situation going forward.&lt;/p&gt;
&lt;p&gt;This blog post gives a short summary from our most recent meeting.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#why-2-ides&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;why-2-ides&quot;&gt;&lt;/a&gt;Why 2 IDEs?&lt;/h1&gt;
&lt;p&gt;The main benefits of rust-analyzer is greater performance (because of fully-lazy compilation model) and somewhat richer feature-set (due to more flexible analysis API).
The main benefits of RLS is precision (it uses &lt;code&gt;rustc&lt;/code&gt; under the hood).
Additionally, RLS is the main consumer of save-analysis infrastructure, which is a good fit for tools which need a static view of the codebase, such as &lt;a href=&quot;https://github.com/rust-dev-tools/cargo-src&quot;&gt;cargo-src&lt;/a&gt; or &lt;a href=&quot;https://code.visualstudio.com/blogs/2019/02/19/lsif&quot;&gt;lsif&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#save-analysis&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;save-analysis&quot;&gt;&lt;/a&gt;Save-analysis&lt;/h1&gt;
&lt;p&gt;What is &amp;quot;save-analysis&amp;quot;?
It is an unstable format which rustc uses to record information about the compiled code.
It contains a pretty high-level information.
For example, for each identifier in the source-crate, save-analyzer will map this identifier to a definition and list of usages.
&lt;code&gt;env RUSTFLAGS=&amp;quot;-Zunstable-options -Zsave-analysis&amp;quot; cargo check&lt;/code&gt; can be used to instruct &lt;code&gt;rustc&lt;/code&gt; to produce save-analysis files (in JSON format).
Because save-analysis is produced directly from rustc iternal data structures, it is guaranteed to be correct (modulo bugs in rustc itself).&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#query-model&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;query-model&quot;&gt;&lt;/a&gt;Query model&lt;/h1&gt;
&lt;p&gt;The fundamental problem with save-analysis is that it is computed for the whole crate at once.
This is pretty slow for non-trivial crates, and is also wasteful.
At any given moment in time, only a small fraction of analysis information is really required.
rust-analyzer solves this by using &lt;a href=&quot;https://github.com/salsa-rs/salsa&quot;&gt;&lt;code&gt;salsa&lt;/code&gt;&lt;/a&gt; queries for code analysis.
The result is a compilation model which is fully lazy across the whole crate graph.
This model is similar to what rustc is using internally, but is more lazy both &amp;quot;vertically&amp;quot; and &amp;quot;horizontally&amp;quot;.
Vertically, &lt;code&gt;rustc&lt;/code&gt; starts to be incremental only after parsing and macro expansion; rust-analyzer is incremental on per-file basis.
Horizontally, &lt;code&gt;rustc&lt;/code&gt; compiles one crate at a time; rust-analyzer uses queries for the whole crate graph.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#way-forward&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;way-forward&quot;&gt;&lt;/a&gt;Way forward&lt;/h1&gt;
&lt;p&gt;Our current hypothesis is that it is possible to integrate both approaches without doubling the engineering effort.
Specifically, we will add an option to rust-analyzer to use save-analysis for find-usages and rename functionality.
That way, we'll get precise results for most important queries, without slowing down completion.
Unlike RLS, however, rust-analyzer will not link to rustc and instead will rely on cargo for running the compiler and producing save-analysis data.
If this approach works, we will consider freezing RLS and focusing fully on rust-analyzer.
Long term, the plan is to unify the save-analysis fallback path and the lazy analysis.&lt;/p&gt;
&lt;p&gt;In parallel to this RLS/rust-analyzer unification effort, we continue to pursue rustc library-ification, with a specific focus on traits solving (via chalk) and type inference.
&amp;quot;Library-ification&amp;quot; is a term we've been using for the process of extracting code out of rustc into re-usable libaries which can be shared by both rustc and rust-analyzer.
The goal is to use library-ification to gradually reduce the amount of duplicated code between rustc and rust-analyzer, with the goal of eventually either having a single code-base, or having the vast majority of the logic be shared.&lt;/p&gt;
</content>

        <author>
            <name>Aleksey Kladov, Igor Matuszewski</name>
        </author>
    </entry>
    
</feed>
